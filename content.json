{"meta":{"title":"我的个人博客","subtitle":"我的个人博客","description":"我的个人博客","author":"露馅的番茄","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于我","date":"2020-04-14T02:47:28.000Z","updated":"2020-09-25T03:04:27.410Z","comments":true,"path":"aboutMe/index.html","permalink":"http://yoursite.com/aboutMe/index.html","excerpt":"","text":"90后，前端程序员 关于我的博客： 博客网址：https://www.btluo.com 博客网址2：https://www.btluo.com/myVueBlog Hexo博客网址：https://52lb.github.io 小程序：罗彪的个人博客 服务器：阿里云服务器 备案号：粤ICP备18137059号-1 语言：nodejs"},{"title":"分类","date":"2020-04-14T02:47:28.000Z","updated":"2020-09-25T03:04:27.410Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-04-14T02:52:11.000Z","updated":"2020-09-25T03:04:27.410Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"小程序图片404错误，怎么使用默认图片替换？","slug":"前端/2020/041401","date":"2020-04-13T16:00:00.000Z","updated":"2020-09-25T03:04:27.406Z","comments":true,"path":"2020/04/14/前端/2020/041401/","link":"","permalink":"http://yoursite.com/2020/04/14/%E5%89%8D%E7%AB%AF/2020/041401/","excerpt":"","text":"概述小程序图片404错误，怎么使用默认图片替换？ 微信小程序图片加载失败怎么显示默认图片？ 解决方案我们在查看image的属性时会发现，image中自带有binderror属性，是可用于处理图片加载失败时的函数： 话不多说，直接上代码： 常用图片引入1.wxml1&lt;image src=&quot;&#123;&#123;imgUrl&#125;&#125;&quot; binderror=&quot;errorImg&quot;&gt;&lt;/image&gt; 2.js12345errorImg: function()&#123; this.setData(&#123; imgUrl: &apos;图片加载失败时需要显示的图片地址&apos; &#125;) &#125; 通常情况下上面的方案就能解决图片加载失败时，显示默认图片的问题，但是如果在小程序中使用了wx:for循环时，如何在图片加载失败时显示默认图片呢？ 解决方法：小程序图片加载视频显示默认图片代码如下： 循环引入图片1.wxml123&lt;view wx:for=&quot;&#123;&#123;imgList&#125;&#125;&quot; wx:key=&quot;&#123;&#123;key&#125;&#125;&quot; wx:for-index=&quot;index&quot;&gt; &lt;image src=&quot;&#123;&#123;item.imgUrl&#125;&#125;&quot; binderror=&quot;errorImg&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot;&gt;&lt;/image&gt;&lt;/view&gt; 2.js1234567errorImg: function(e) &#123; var index = e.currentTarget.dataset.index var img = &apos;imgList[&apos; + index + &apos;].imgUrl&apos; this.setData(&#123; [img]: &apos;图片加载失败时需要显示的图片地址&apos; &#125;)&#125;,","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"Markdown 语法大全","slug":"IT/2020/041401","date":"2020-04-13T16:00:00.000Z","updated":"2020-09-25T03:04:27.391Z","comments":true,"path":"2020/04/14/IT/2020/041401/","link":"","permalink":"http://yoursite.com/2020/04/14/IT/2020/041401/","excerpt":"","text":"概述Markdown是一种可以使用普通文本编辑器编写的标记语言，通过类似HTML的标记语法，它可以使普通文本内容具有一定的格式，本文主要介绍md的基础语法。 1.标题支持6种大小的标题，分别对应#，##，###，####，#####，######和样式文件中的h1，h2，h3，h4，h5，h6如： 1## 我是标题h2 2.加粗1**我是加粗** 3.斜体1我是*斜体* 4.加粗的斜体1我是***加粗的斜体*** 5.超链接①.外链超链接1[我是超链接](https://www.btluo.com) ②.页面内的超链接123[我是页面内的超链接](#page1)注：使用页面内的超链接时，需要先在要跳转的到地方放一个id为page1：&lt;a id=&quot; page1 &quot;&gt;链接&lt;/a&gt;的锚点。 6.删除1我是~~删除~~ 7.图片1![我是图片](https://www.btluo.com/images/separateImg.png) 8.列表①.有序列表文字前加序号，序号后面加英文符号.，并加一个空格即可。 如： 1231. 有序列表 12. 有序列表 23. 有序列表 3 ②.无序列表在一段文字前添加特定的符号即可，可以使用* - + 等，符号与文字之间需要空格。 如： 123* 无序列表1* 无序列表2* 无序列表3 或： 123- 无序列表4- 无序列表5- 无序列表6 或： 123+ 无序列表7+ 无序列表8+ 无序列表9 三种符号显示的结果是一样的； ③.有序列表与无序列表的混用1234567891011121. 有序列表1 - 无序列表1 * 无序列表2 + 无序列表32. 有序列表2 - 无序列表4 + 无序列表5 * 无序列表63. 有序列表3 + 无序列表7 * 无序列表8 - 无序列表9 9.字体字号颜色123456&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;&lt;font color=#0099ff size=7 face=&quot;黑体&quot;&gt;color=#0099ff size=72 face=&quot;黑体&quot;&lt;/font&gt;&lt;font color=#00ffff size=72&gt;color=#00ffff&lt;/font&gt;&lt;font color=gray size=72&gt;color=gray&lt;/font&gt; Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3。 10.引用在需要引用的文字前添加符号：&gt;，即可使用引用块，如下: 12&gt;我是引用&gt;啦啦啦，哈哈，看我，是不是很显眼 11.分割线在需要进行分割的两行之间添加单独一行内容： 1**** 12.表格可直接在这个网址生成： https://tool.lu/tables 13.代码行内代码的语法是在代码前后用符号：`，如： 1`&lt;div&gt;我是一条代码&lt;/div&gt;` 代码块的使用语法是在代码前后添加三个`符号，如： 123456```&lt;div&gt; &lt;p&gt;我是一串代码&lt;/p&gt;&lt;/div&gt;`` `(原谅我打了个空格，不然就被解析了)","categories":[{"name":"IT","slug":"IT","permalink":"http://yoursite.com/categories/IT/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"Hexo网站部署到GitHub时出现spawn failed错误","slug":"前端/2020/041402","date":"2020-04-13T16:00:00.000Z","updated":"2020-09-25T03:04:27.406Z","comments":true,"path":"2020/04/14/前端/2020/041402/","link":"","permalink":"http://yoursite.com/2020/04/14/%E5%89%8D%E7%AB%AF/2020/041402/","excerpt":"","text":"概述在完善完hexo的搜索功能，及新增几篇文章想上传github时，居然出现spawn failed错误了？？ 问题在完善完hexo的搜索功能，及新增几篇文章想上传github时，在cmd中输入hexo deploy命令部署到GitHub上时，出现如下图所示的问题 : 百度了一下问题，网上说，使用Get Bash Here 上传就能解决，然而，使用Get Bash Here 上传它还是报了这个错，伤心。 然后去百度翻译了一下这个错： 请确保您拥有正确的访问权限存储库存在。致命的错误。或许您可以在这里找到解决方案：https://hexo.io/docs/troubleshooting.html 哦豁，可能是我本地的ssh密钥没生成，或者不小心被我删了，然后只好重新生成了一下： 生成方法在之前的文章中有介绍：如何使用Hexo建站 只需要看如何创建SSH就行； 然后在重新hexo d一下，嗯，nice，成功了：","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"http://yoursite.com/tags/HEXO/"}]},{"title":"微信小程序-保存视频到本地相册","slug":"前端/2020/040801","date":"2020-04-07T16:00:00.000Z","updated":"2020-09-25T03:04:27.405Z","comments":true,"path":"2020/04/08/前端/2020/040801/","link":"","permalink":"http://yoursite.com/2020/04/08/%E5%89%8D%E7%AB%AF/2020/040801/","excerpt":"","text":"概述微信小程序进行微信授权并保存视频到本地 功能小程序中如何将保存视频到本地相册； 代码1.wxml1&lt;view bindtap=&quot;downloadVideo&quot;&gt;下载视频&lt;/view&gt; 2.index.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 下载视频前授权保存相册downloadVideo:function()&#123; let that = this , videoUrl = this.data.videoData.videoUrl; // 判断是否有视频 if(videoUrl == &quot;&quot;)&#123; util.showErrorModal(&quot;暂无可下载视频，请稍后重试！&quot;); &#125;else&#123; wx.getSetting(&#123; success(res) &#123; if (res.authSetting[&quot;scope.writePhotosAlbum&quot;]) &#123; that.saveVideo(); &#125; else if (res.authSetting[&quot;scope.writePhotosAlbum&quot;] === undefined) &#123; wx.authorize(&#123; scope: &quot;scope.writePhotosAlbum&quot;, success() &#123; that.saveVideo(); &#125;, fail() &#123; wx.showToast(&#123;title: &quot;您没有授权，无法保存视频到相册哦~&quot;, icon: &quot;none&quot;&#125;); &#125; &#125;) &#125; else &#123; wx.openSetting(&#123; success(res) &#123; if (res.authSetting[&quot;scope.writePhotosAlbum&quot;]) &#123; that.saveVideo(); &#125; else &#123; wx.showToast(&#123;title: &quot;您没有授权，无法保存视频到相册哦~&quot;, icon: &quot;none&quot;&#125;); &#125; &#125; &#125;) &#125; &#125; &#125;) &#125;&#125;,// 保存视频到相册saveVideo:function()&#123; let fileName = new Date().valueOf() , videoUrl = this.data.videoData.videoUrl; wx.showLoading(&#123; title: &apos;视频下载中&apos;, mask: true &#125;); wx.downloadFile(&#123; url: videoUrl, filePath: wx.env.USER_DATA_PATH + &apos;/&apos; + fileName + &apos;.mp4&apos;, success: res =&gt; &#123; console.log(res); let filePath = res.filePath; wx.saveVideoToPhotosAlbum(&#123; filePath, success: file =&gt; &#123; wx.hideLoading(); util.showErrorModal(&quot;下载成功！！&quot;); // 删除本地缓存文件 let fileMgr = wx.getFileSystemManager(); fileMgr.unlink(&#123; filePath: wx.env.USER_DATA_PATH + &apos;/&apos; + fileName + &apos;.mp4&apos;, success: function (r) &#123; &#125;, &#125;) &#125;, fail: err =&gt; &#123; wx.hideLoading(); console.log(err) &#125; &#125;) &#125; &#125;)&#125;, 3.util.js 1234567891011121314151617181920// 消息提示function showErrorToast(msg) &#123; wx.showToast(&#123; title: msg, icon: &apos;loading&apos;, &#125;)&#125;// 错误提示function showErrorModal(msg) &#123; wx.showModal(&#123; title: &apos;温馨提示&apos;, content: msg, showCancel: false &#125;)&#125;module.exports = &#123; showErrorToast, showErrorModal,&#125; 注：只贴了与本文章有关部分代码； 亲测下载成功；","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"如何使用一段css让网站变灰？","slug":"前端/2020/040301","date":"2020-04-02T16:00:00.000Z","updated":"2020-09-25T03:04:27.405Z","comments":true,"path":"2020/04/03/前端/2020/040301/","link":"","permalink":"http://yoursite.com/2020/04/03/%E5%89%8D%E7%AB%AF/2020/040301/","excerpt":"","text":"概述为表达全国人民对抗击新冠肺炎疫情斗争牺牲烈士和逝世通报的深切哀悼，国务院发布公告明天十点进行全国哀悼日，想到以往默哀日访问网站时会发现大部分网站会变成全灰，因此试了一下如何用一段css让全站变灰 问题如何使用一段css代码使整个网站变灰； 方法使用css3新增的filter属性修改html样式：filter:grayscale来调整元素的灰度值； 代码1234567html &#123; filter: grayscale(100%); -webkit-filter: grayscale(100%); -moz-filter: grayscale(100%); -ms-filter: grayscale(100%); -o-filter: grayscale(100%);&#125; 效果","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"微信小程序-使用wxParse解析html","slug":"前端/2020/040201","date":"2020-04-01T16:00:00.000Z","updated":"2020-09-25T03:04:27.404Z","comments":true,"path":"2020/04/02/前端/2020/040201/","link":"","permalink":"http://yoursite.com/2020/04/02/%E5%89%8D%E7%AB%AF/2020/040201/","excerpt":"","text":"概述在开发博客项目时遇到在微信小程序里需要显示文章内容，文章内容是通过管理后台中的wangEditor富文本编写，而小程序是不支持html格式的，那我们需要显示html内容的时侯，就需要通过wxParse来实现。 一.下载wxParseGitHub下载地址：https://github.com/icindy/wxParse 二.拷贝到项目中将下载完成的wxParse文件夹，拷贝到项目中； 注：注意路径，根据拷贝位置自行修改引入路径； 三.使用步骤1.引入wxParse的样式1@import &quot;/page/wxParse/wxParse.wxss&quot;; 2.引入wxParse在需要加载html内容的页面的js文件里引入wxParse： 1var WxParse = require(&apos;../../wxParse/wxParse.js&apos;); 3.调用wxParse在js中调用WxParse.wxParse方法来设置html内容： 123456789101112131415161718192021222324252627282930/*** WxParse.wxParse(bindName , type, data, target,imagePadding)* 1.bindName绑定的数据名(必填)* 2.type可以为html或者md(必填)* 3.data为传入的具体数据(必填)* 4.target为Page对象,一般为this(必填)* 5.imagePadding为当图片自适应是左右的单一padding(默认为0,可选)*/Page(&#123; data: &#123; &#125;, onLoad: function () &#123; var that = this; wx.request(&#123; url: &quot;&quot;, method: &quot;POST&quot;, data: &#123; &quot;id&quot;:13 &#125;, header: &#123; &quot;content-type&quot;: &quot;application/json&quot; &#125;, success: function(res) &#123; var article = res.data[0].content; WxParse.wxParse(&apos;article&apos;, &apos;html&apos;, article, that,5); &#125; &#125;) &#125;&#125;) 4.在页面中引用模板12&lt;import src=&quot;../../wxParse/wxParse.wxml&quot;/&gt;&lt;template is=&quot;wxParse&quot; data=&quot;&#123;&#123;wxParseData:article.nodes&#125;&#125;&quot;/&gt; 四.效果展示","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"Html中如何引入图标？","slug":"前端/2020/040202","date":"2020-04-01T16:00:00.000Z","updated":"2020-09-25T03:04:27.404Z","comments":true,"path":"2020/04/02/前端/2020/040202/","link":"","permalink":"http://yoursite.com/2020/04/02/%E5%89%8D%E7%AB%AF/2020/040202/","excerpt":"","text":"概述如题，在日常开发网站时，过多的图片往往会影响网页的加载，因此我们往往会需要用到小图标，因此本文主要讲解如何在网页中引入小图标； 问题HTML中如何引入图标（以font awesome为例）； 方法1.引入js可直接引入或前往font awesome官网下载： 1&lt;script defer src=&quot;https://use.fontawesome.com/releases/v5.0.8/js/all.js&quot;&gt;&lt;/script&gt; 2.选择图标打开官网，任意选择一款图标： 3.复制代码1&lt;i class=&quot;fa fa-camera-retro&quot;&gt;&lt;/i&gt; 也可根据需要改变图标大小（也可使用font-size）： 据需要还能修改图标颜色等样式； 4.使用图标将图标代码复制到需要的div或者span等标签中： 1&lt;div&gt;&lt;i class=&quot;fa fa-camera-retro&quot;&gt;&lt;/i&gt;&lt;/div&gt; 然后就能正常使用了；","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"jquery-网站图片放大缩小","slug":"前端/2020/033101","date":"2020-03-26T16:00:00.000Z","updated":"2020-09-25T03:04:27.404Z","comments":true,"path":"2020/03/27/前端/2020/033101/","link":"","permalink":"http://yoursite.com/2020/03/27/%E5%89%8D%E7%AB%AF/2020/033101/","excerpt":"","text":"概述完善了一下我的官网博客中图片不能点击放大的功能！ 功能点击官网内文章图片显示大图，再次点击可关闭弹出的图片。 效果图 代码html： 12345&lt;div id=&quot;outerdiv&quot; style=&quot;position:fixed;top:0;left:0;background:rgba(0,0,0,0.7);z-index:2;width:100%;height:100%;display:none;&quot;&gt; &lt;div id=&quot;innerdiv&quot; style=&quot;position:absolute;&quot;&gt; &lt;img id=&quot;bigimg&quot; style=&quot;border:5px solid #fff;&quot; src=&quot;&quot; /&gt; &lt;/div&gt;&lt;/div&gt; js： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 点击图片放大,再点缩小$(function () &#123; $(&quot;#articleDetail img&quot;).click(function () &#123; var _this = $(this);//将当前的pimg元素作为_this传入函数 imgShow(&quot;#outerdiv&quot;, &quot;#innerdiv&quot;, &quot;#bigimg&quot;, _this); &#125;);&#125;);function imgShow(outerdiv, innerdiv, bigimg, _this) &#123; var src = _this.attr(&quot;src&quot;);//获取当前点击的pimg元素中的src属性 $(bigimg).attr(&quot;src&quot;, src);//设置#bigimg元素的src属性 /*获取当前点击图片的真实大小，并显示弹出层及大图*/ $(&quot;&lt;img/&gt;&quot;).attr(&quot;src&quot;, src).load(function () &#123; var windowW = $(window).width();//获取当前窗口宽度 var windowH = $(window).height();//获取当前窗口高度 var realWidth = this.width;//获取图片真实宽度 var realHeight = this.height;//获取图片真实高度 var imgWidth, imgHeight; var scale = 0.8;//缩放尺寸，当图片真实宽度和高度大于窗口宽度和高度时进行缩放 if (realHeight &gt; windowH * scale) &#123;//判断图片高度 imgHeight = windowH * scale;//如大于窗口高度，图片高度进行缩放 imgWidth = imgHeight / realHeight * realWidth;//等比例缩放宽度 if (imgWidth &gt; windowW * scale) &#123;//如宽度扔大于窗口宽度 imgWidth = windowW * scale;//再对宽度进行缩放 &#125; &#125; else if (realWidth &gt; windowW * scale) &#123;//如图片高度合适，判断图片宽度 imgWidth = windowW * scale;//如大于窗口宽度，图片宽度进行缩放 imgHeight = imgWidth / realWidth * realHeight;//等比例缩放高度 &#125; else &#123;//如果图片真实高度和宽度都符合要求，高宽不变 imgWidth = realWidth; imgHeight = realHeight; &#125; $(bigimg).css(&quot;width&quot;, imgWidth);//以最终的宽度对图片缩放 var w = (windowW - imgWidth) / 2;//计算图片与窗口左边距 var h = (windowH - imgHeight) / 2;//计算图片与窗口上边距 $(innerdiv).css(&#123; &quot;top&quot;: h, &quot;left&quot;: w &#125;);//设置#innerdiv的top和left属性 $(outerdiv).fadeIn(&quot;fast&quot;);//淡入显示#outerdiv及.pimg &#125;); $(outerdiv).click(function () &#123;//再次点击淡出消失弹出层 $(this).fadeOut(&quot;fast&quot;); &#125;);&#125; 转载：https://blog.csdn.net/yournevermore/article/details/88583040","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"微信小程序-文章评论功能","slug":"前端/2020/032701","date":"2020-03-26T16:00:00.000Z","updated":"2020-09-25T03:04:27.403Z","comments":true,"path":"2020/03/27/前端/2020/032701/","link":"","permalink":"http://yoursite.com/2020/03/27/%E5%89%8D%E7%AB%AF/2020/032701/","excerpt":"","text":"概述在大部分博客网站中，评论功能是与博主沟通交流必不可少的功能，目前我的博客中的文章只提供了阅读功能，但是没有评论功能，因此我在闲暇时间，查阅资料并研究了一下评论功能，来完善一下我的小程序； 一.简书前端界面分析首先我们先研究下简书的前端界面长什么样，知道了前端需要什么数据，我们在根据自己小程序的需求来设计数据库。 以简书为例，一个项目下面可能会有多条评论。但评论下面可能会有很多条的回复；我们先将简书下方的直接对文章的评论的称为父评论，每条父评论下方的回复称之为子评论； 即简书的文章下可能有多个父评论，每个父评论下可能有多个子评论。他们之间都是一对多的关系；因此我们将评论表的字段设计为： 主键ID（评论ID），blog_id(对应博客文章ID)，blog_type（因为我的博客技术文章和生活随笔文章放了两张不同的表，所以用来区别文章类型），wimini_user_id（评论用户ID，用来链接用户表获取对应的头像以及名称），reply_wxmini_id（回复者用户ID），pid（父级ID，根据pid找到对应的评论，pid为0代表父评论，其他则为对应pid的回复），praise（点赞数，暂时还没弄，先留着），content（评论内容），create_time（创建时间）； 二.创建数据库表123456789101112131415CREATE TABLE `mb_comment` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;评论ID&apos;, `blog_id` int(11) DEFAULT NULL COMMENT &apos;博客ID&apos;, `blog_type` varchar(11) DEFAULT NULL COMMENT &apos;博客类型（0：技术文章，1：随笔文章）&apos;, `wxmini_id` int(11) DEFAULT NULL COMMENT &apos;评论者微信用户ID&apos;, `reply_wxmini_id` int(11) DEFAULT NULL COMMENT &apos;回复者微信用户ID&apos;, `pid` int(11) DEFAULT NULL COMMENT &apos;父评论ID&apos;, `content` varchar(256) DEFAULT NULL COMMENT &apos;评论内容&apos;, `praise` int(64) DEFAULT &apos;0&apos; COMMENT &apos;点赞数&apos;, `create_time` datetime NOT NULL COMMENT &apos;创建时间&apos;, `createdAt` varchar(64) DEFAULT NULL COMMENT &apos;创建时间戳&apos;, `updatedAt` varchar(64) DEFAULT NULL COMMENT &apos;更新时间戳&apos;, `version` varchar(64) DEFAULT NULL COMMENT &apos;版本&apos;, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 三.后台接口返回数据1.数据库用的mySql，通过查询文章id来查找对应的评论，在通过用户id查询评论人信息，以及被回复人信息，先获取到当前所有评论包括回复信息： SELECT a.id,a.pid,a.blog_id blogId,a.wxmini_id wxminiId,b.user_name userName,b.img_url imgUrl,c.user_name reUserName,c.img_url reImgUrl,a.content,DATE_FORMAT(a.create_time,’%Y-%m-%d %T’) createTime FROM mb_comment a LEFT JOIN wxmini_user_info b ON a.wxmini_id=b.id LEFT JOIN wxmini_user_info c ON a.reply_wxmini_id=c.id WHERE a.blog_id = “ + 博客文章id + “ AND a.blog_type = “ + 文章类型 2.将返回的json数据中根据id=pid把回复对应到相应的评论中： 12345678910111213var map = &#123;&#125;;result.forEach(function (item) &#123; map[item.id] = item;&#125;);var resultList = [];result.forEach(function (item) &#123; var parent = map[item.pid]; if (parent) &#123; (parent.children || (parent.children = [])).push(item); &#125; else &#123; resultList.push(item); &#125;&#125;); 3.编写接口： 我的后台使用的是nodejs的koa2，因此结合上面获取内容获取文章评论接口如下： 123456789101112131415161718192021222324252627282930313233// 文章评论列表&quot;GET /api/wxmini/commentList&quot;: async (ctx, next) =&gt; &#123; let parameter = &#123;&#125;; ctx.request.querystring.replace(/([^=&amp;]+)=([^&amp;]*)/g, function(m,key,value) &#123; parameter[decodeURIComponent(key)] = decodeURIComponent(value); &#125;); console.log(parameter); // 本博客下所有评论回复 let result = await db.sequelize.query(&quot;SELECT a.id,a.pid,a.blog_id blogId,a.wxmini_id wxminiId,b.user_name userName,b.img_url imgUrl,c.user_name reUserName,c.img_url reImgUrl,a.content,DATE_FORMAT(a.create_time,&apos;%Y-%m-%d %T&apos;) createTime FROM mb_comment a LEFT JOIN wxmini_user_info b ON a.wxmini_id=b.id LEFT JOIN wxmini_user_info c ON a.reply_wxmini_id=c.id WHERE a.blog_id = &quot; + parameter.blogId + &quot; AND a.blog_type = &quot; + parameter.blogType, &#123; type: db.sequelize.QueryTypes.SELECT &#125; ).then(function(results) &#123; return results; &#125;); // 将回复对应到相应的评论中 var map = &#123;&#125;; result.forEach(function (item) &#123; map[item.id] = item; &#125;); var resultList = []; result.forEach(function (item) &#123; var parent = map[item.pid]; if (parent) &#123; (parent.children || (parent.children = [])).push(item); &#125; else &#123; resultList.push(item); &#125; &#125;); ctx.body = &#123; code: 0, data: resultList &#125;;&#125;, 返回接口如下： 四.前端页面展示1.wxml: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!-- 新增评论 --&gt;&lt;view class=&quot;space&quot;&gt;&lt;/view&gt;&lt;view class=&quot;commentBox&quot;&gt; &lt;view class=&quot;commentHead flex ac jcs&quot;&gt; &lt;view class=&quot;f32 fwb&quot; wx:if=&quot;&#123;&#123;commentList.length &gt; 0&#125;&#125;&quot;&gt;评论(&#123;&#123;commentList.length&#125;&#125;)&lt;/view&gt; &lt;view class=&quot;f32 fwb&quot; wx:else&gt;暂无评论&lt;/view&gt; &lt;view class=&quot;f28 cMain flex ac&quot; bindtap=&quot;showCommentBox&quot; data-type=&quot;comment&quot; data-wxminiid=&quot;0&quot; data-pid=&quot;0&quot; data-fidx=&quot;-1&quot;&gt; &lt;image src=&quot;/img/iconEdit.png&quot;&gt;&lt;/image&gt;写评论 &lt;/view&gt; &lt;/view&gt; &lt;!-- 评论列表 --&gt; &lt;view class=&quot;commentBody&quot; wx:if=&quot;&#123;&#123;commentList.length &gt; 0&#125;&#125;&quot; wx:for=&quot;&#123;&#123;commentList&#125;&#125;&quot; wx:for-index=&quot;fidx&quot; wx:key=&quot;&#123;&#123;index&#125;&#125;&quot;&gt; &lt;view class=&quot;commentList flex&quot;&gt; &lt;view class=&quot;commentLeft&quot;&gt; &lt;image src=&quot;&#123;&#123;item.imgUrl&#125;&#125;&quot;&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class=&quot;commentRight&quot;&gt; &lt;view class=&quot;rightDetail&quot;&gt; &lt;view class=&quot;f30 fwb&quot;&gt;&#123;&#123;item.userName&#125;&#125;&lt;/view&gt; &lt;view class=&quot;f30 c888 commentContent&quot;&gt;&#123;&#123;item.content&#125;&#125;&lt;/view&gt; &lt;view class=&quot;f28 c888 flex ac jcs&quot;&gt; &lt;view&gt;&#123;&#123;item.createTime&#125;&#125;&lt;/view&gt; &lt;view class=&quot;commentIcon&quot; bindtap=&quot;showCommentBox&quot; data-type=&quot;reply&quot; data-wxminiid=&quot;&#123;&#123;item.wxminiId&#125;&#125;&quot; data-pid=&quot;&#123;&#123;item.id&#125;&#125;&quot; data-username=&quot;&#123;&#123;item.userName&#125;&#125;&quot; data-fidx=&quot;&#123;&#123;fidx&#125;&#125;&quot;&gt; &lt;image src=&quot;/img/iconReply.png&quot;&gt;&lt;/image&gt; &lt;!-- &lt;image src=&quot;/img/iconReply.png&quot; class=&quot;iconReply&quot;&gt;&lt;/image&gt; --&gt; &lt;!-- &lt;image src=&quot;/img/iconPraise.png&quot;&gt;&lt;/image&gt; --&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 回复列表 --&gt; &lt;view class=&quot;replyList flex&quot; wx:if=&quot;&#123;&#123;idx &lt; (uhide==fidx?item.children.length:moreReplyMax)&#125;&#125;&quot; wx:for=&quot;&#123;&#123;item.children&#125;&#125;&quot; wx:for-index=&quot;idx&quot; wx:for-item=&quot;children&quot; wx:key=&quot;&#123;&#123;index&#125;&#125;&quot;&gt; &lt;view class=&quot;replyLeft&quot;&gt; &lt;image src=&quot;&#123;&#123;children.imgUrl&#125;&#125;&quot;&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class=&quot;replyRight&quot;&gt; &lt;view class=&quot;f30 fwb&quot;&gt;&#123;&#123;children.userName&#125;&#125;&lt;/view&gt; &lt;view class=&quot;f30 c888 replyContent&quot;&gt; &lt;text class=&quot;cBlue&quot;&gt;@&#123;&#123;children.reUserName&#125;&#125;&lt;/text&gt;&#123;&#123;children.content&#125;&#125; &lt;/view&gt; &lt;view class=&quot;f28 c888 flex ac&quot;&gt; &lt;view class=&quot;time&quot;&gt;&#123;&#123;children.createTime&#125;&#125;&lt;/view&gt; &lt;view bindtap=&quot;showCommentBox&quot; data-type=&quot;reply&quot; data-wxminiid=&quot;&#123;&#123;children.wxminiId&#125;&#125;&quot; data-pid=&quot;&#123;&#123;children.pid&#125;&#125;&quot; data-username=&quot;&#123;&#123;children.userName&#125;&#125;&quot; data-fidx=&quot;&#123;&#123;fidx&#125;&#125;&quot;&gt;回复&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 点击查看更多回复 --&gt; &lt;view class=&quot;moreReply flex ac&quot; wx:if=&quot;&#123;&#123;item.children.length&gt;(uhide==fidx?item.children.length:moreReplyMax)&#125;&#125;&quot;&gt; &lt;view&gt;&lt;image src=&quot;/img/read.png&quot;&gt;&lt;/image&gt;&lt;/view&gt; &lt;view class=&quot;f28 c888&quot;&gt;还有&#123;&#123;item.children.length - moreReplyMax&#125;&#125;条评论，&lt;/view&gt; &lt;view class=&quot;f28 cBlue&quot; bindtap=&quot;toggleMoreReply&quot; data-fidx=&quot;&#123;&#123;fidx&#125;&#125;&quot;&gt;点击查看更多&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 没有更多评论了 --&gt; &lt;view class=&quot;commentNoMore tc&quot; wx:if=&quot;&#123;&#123;commentList.length &gt; 0&#125;&#125;&quot;&gt;没有更多评论了~&lt;/view&gt; &lt;!-- 暂无评论 --&gt; &lt;view wx:if=&quot;&#123;&#123;commentList.length == 0&#125;&#125;&quot; class=&quot;noComment tc&quot;&gt; &lt;image src=&quot;/img/iconCommentNo.png&quot;&gt;&lt;/image&gt; &lt;view&gt;来都来了，不想&lt;text class=&quot;cBlue&quot; bindtap=&quot;showCommentBox&quot; data-type=&quot;comment&quot; data-wxminiid=&quot;0&quot; data-pid=&quot;0&quot; data-fidx=&quot;-1&quot;&gt;说一些什么&lt;/text&gt;咩~&lt;/view&gt; &lt;/view&gt;&lt;/view&gt;&lt;view class=&quot;space&quot;&gt;&lt;/view&gt;&lt;!-- 写评论 --&gt;&lt;view class=&quot;addCBox&quot; wx:if=&quot;&#123;&#123;editComment&#125;&#125;&quot;&gt; &lt;view class=&quot;addCBg&quot;&gt;&lt;/view&gt; &lt;view class=&quot;addCBody bgFFF&quot;&gt; &lt;view class=&quot;addContent&quot;&gt; &lt;textarea placeholder=&quot;&#123;&#123;contentTip&#125;&#125;&quot; maxlength=&quot;-1&quot; bindinput=&quot;getCommentContent&quot; value=&quot;&#123;&#123;content&#125;&#125;&quot;&gt;&lt;/textarea&gt; &lt;/view&gt; &lt;view class=&quot;operation flex ac &quot;&gt; &lt;view class=&quot;cancel bgF0 c888&quot; bindtap=&quot;hideCommentBox&quot;&gt;取消&lt;/view&gt; &lt;view class=&quot;bgMain cfff&quot; bindtap=&quot;addNewComment&quot;&gt;确认&lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 2.wxss: 12345678910111213141516171819202122232425262728293031323334/* 新增评论 */.commentBox&#123;width: 92%;margin: 0 auto;margin-top: 40rpx;&#125;.commentBox .commentHead image&#123;width: 30rpx; height: 30rpx; margin-right: 10rpx;&#125;.commentBox .commentBody&#123;width: 100%;overflow: hidden; margin: 30rpx 0;border-top: 1px solid #e6e6e6;padding-top: 30rpx;&#125;.commentBox .commentBody .commentList .commentLeft&#123;width: 15%;&#125;.commentBox .commentBody .commentList .commentLeft image&#123;width: 64rpx; height: 64rpx;&#125;.commentBox .commentBody .commentList .commentRight&#123;width: 85%;&#125;.commentBox .commentBody .commentList .commentRight .commentContent&#123;margin: 20rpx 0;&#125;.commentBox .commentBody .commentList .commentRight .commentIcon image&#123;width: 40rpx; height: 40rpx;&#125;.commentBox .commentBody .commentList .commentRight .commentIcon .iconReply&#123;margin-right: 40rpx;&#125;.commentBox .commentBody .commentList .commentRight .replyList&#123;width: 100%; overflow: hidden; margin-top: 30rpx; padding: 30rpx 0; border-top: 1px solid #e6e6e6;&#125;.commentBox .commentBody .commentList .commentRight .replyList .replyLeft&#123;width: 15%;&#125;.commentBox .commentBody .commentList .commentRight .replyList .replyLeft image&#123;width: 50rpx; height: 50rpx;&#125;.commentBox .commentBody .commentList .commentRight .replyList .replyRight&#123;width: 85%;&#125;.commentBox .commentBody .commentList .commentRight .replyList .replyRight .replyContent&#123;margin: 20rpx 0;line-height: 50rpx;&#125;.commentBox .commentBody .commentList .commentRight .replyList .replyRight .replyContent text&#123;margin-right: 20rpx;&#125;.commentBox .commentBody .commentList .commentRight .replyList .replyRight .time&#123;margin-right: 20rpx;&#125;/* 更多回复 */.commentBox .commentBody .commentList .commentRight .moreReply&#123;width: 100%;overflow: hidden;padding-top: 30rpx;border-top: 1px solid #e6e6e6;&#125;.commentBox .commentBody .commentList .commentRight .moreReply image&#123;width: 32rpx;height: 32rpx;margin-right: 10rpx;&#125;/* 没有更多评论了 */.commentBox .commentNoMore&#123;width: 100%;overflow: hidden;padding: 30rpx 0;border-top: 1px solid #e6e6e6;&#125;/* 暂无评论 */.commentBox .noComment&#123;width: 100%;overflow: hidden;padding: 100rpx 0;&#125;.commentBox .noComment image&#123;width: 350rpx;height: 150rpx;margin-bottom: 50rpx;&#125;/* 写评论 */.addCBox&#123;position: fixed; top: 0; left: 0; background: rgba(0, 0, 0, 0.7); width: 100%; z-index: 1001; height: 100vh;&#125;.addCBox .addCBg&#123;position: absolute; top: 0; left: 0; width: 100%; z-index: 1; height: 100vh;&#125;.addCBox .addCBody&#123;width: 100%;position: relative;z-index: 10;&#125;.addCBox .addCBody .addContent&#123;width: 100%;padding: 20rpx;box-sizing: border-box;&#125;.addCBox .addCBody .addContent textarea&#123;width: 100%;&#125;.addCBox .addCBody .operation&#123;width: 100%;padding: 30rpx 20rpx;justify-content: flex-end;&#125;.addCBox .addCBody .operation&gt;view&#123;padding: 10rpx 30rpx;border-radius: 10rpx;&#125;.addCBox .addCBody .operation .cancel&#123;margin-right: 20rpx;&#125; 3.js: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170var util = require(&apos;../../utils/util.js&apos;);var api = require(&apos;../../config/api.js&apos;);var app = getApp();Page(&#123; /** * commentList:评论列表 * content:评论内容 * contentTip:评论内容提示 * commentType:评论类型：comment-评论，reply-回复 * rWxminiId:被回复人用户id * pid:评论id * uhide:当前展开更多回复id * moreReply:是否显示更多回复 * moreReplyMax：默认显示回复数 */ data: &#123; commentList: [], content: &quot;&quot;, contentTip: &quot;请输入您的评论内容&quot;, commentType: &quot;comment&quot;, rWxminiId: 0, pid: 0, uhide: null, moreReply: false, moreReplyMax: 2 &#125;, //点击切换隐藏和显示更多回复 toggleMoreReply: function (e) &#123; var that = this; var fidx = e.currentTarget.dataset.fidx; that.setData(&#123; uhide: fidx &#125;) &#125;, // 显示写评论窗口 showCommentBox: function (e) &#123; let that = this , contentTip = &quot;请输入您的评论内容&quot; , fidx = e.currentTarget.dataset.fidx , commentType = e.currentTarget.dataset.type , rWxminiId = e.currentTarget.dataset.wxminiid , pid = e.currentTarget.dataset.pid; if (commentType == &quot;reply&quot;) &#123; contentTip = &quot;@&quot; + e.currentTarget.dataset.username; &#125; else &#123; contentTip = &quot;请输入您的评论内容&quot;; &#125; that.setData(&#123; editComment: true, uhide: fidx, commentType: commentType, rWxminiId: rWxminiId, pid: pid, contentTip: contentTip &#125;) &#125;, // 隐藏评论窗口 hideCommentBox: function (e) &#123; let that = this; that.setData(&#123; editComment: false &#125;) &#125;, // 获取输入的评论内容 getCommentContent: function (e) &#123; let content = e.detail.value; this.setData(&#123; content: content &#125;) &#125;, // 获取评论列表GetCommentList getCommentList: function () &#123; let that = this , blogId = this.data.diaryId; util.request(api.GetCommentList, &#123; blogId: blogId, blogType: 1 &#125;).then(res =&gt; &#123; if (res.code == 0) &#123; that.setData(&#123; commentList: res.data &#125;) &#125; else &#123; console.log(&quot;获取评论失败&quot;); &#125; &#125;) &#125;, // 获取评论数据 addNewComment: function () &#123; let data = &#123; blogId: this.data.diaryId, blogType: 1, wxminiId: parseInt(wx.getStorageSync(&quot;wxminiId&quot;)), rWxminiId: this.data.rWxminiId, pid: this.data.pid, content: this.data.content, &#125;; this.saveComment(data); &#125;, // 评论回复请求 saveComment: function (data) &#123; let that = this , isLogin = this.data.isLogin; if (data.content == &quot;&quot;) &#123; util.showErrorModal(&quot;请输入评论内容哦！&quot;); return false; &#125; if (isLogin &amp;&amp; wx.getStorageSync(&quot;wxminiId&quot;)) &#123; wx.showLoading(&#123; title: &apos;加载中...&apos;, mask: true &#125;); util.request(api.SaveComment, data, &apos;POST&apos;).then(res =&gt; &#123; wx.hideLoading(); if (res.code == 0) &#123; wx.showToast(&#123; title: &apos;评论成功&apos; &#125;) that.setData(&#123; editComment: false, content: &quot;&quot; &#125;) that.getCommentList(); &#125; else &#123; util.showErrorModal(res.msg); &#125; &#125;) &#125; else &#123; wx.showModal(&#123; title: &apos;温馨提示！&apos;, content: &apos;骚瑞哦，授权后才能评论哦~&apos;, confirmText: &quot;去授权&quot;, success(res) &#123; if (res.confirm) &#123; wx.navigateTo(&#123; url: &apos;/pages/authorization/authorization&apos;, &#125;) &#125; else if (res.cancel) &#123; console.log(&apos;用户点击取消&apos;) &#125; &#125; &#125;) return false; &#125; &#125;, onLoad: function (options) &#123; var scene = decodeURIComponent(options.scene); if (scene != undefined &amp;&amp; scene != &quot;undefined&quot; &amp;&amp; scene != &quot;&quot;) &#123; this.setData(&#123; diaryId: scene &#125;); &#125; else &#123; this.setData(&#123; diaryId: options.diaryId &#125;); &#125; this.getCommentList(); &#125;, onShow: function () &#123; // 查看是否登录，用于授权 let isLogin = wx.getStorageSync(&quot;isLogin&quot;); if (isLogin) &#123; this.setData(&#123; isLogin: isLogin &#125;) &#125; else &#123; this.setData(&#123; isLogin: false &#125;) &#125; &#125;, onPullDownRefresh: function () &#123; wx.showNavigationBarLoading() //在标题栏中显示加载 this.getCommentList(); wx.hideNavigationBarLoading() //完成停止加载 wx.stopPullDownRefresh() //停止下拉刷新 &#125;,&#125;) 页面展示","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"如何在mysql中存emoji表情？","slug":"前端/2020/032702","date":"2020-03-26T16:00:00.000Z","updated":"2020-09-25T03:04:27.403Z","comments":true,"path":"2020/03/27/前端/2020/032702/","link":"","permalink":"http://yoursite.com/2020/03/27/%E5%89%8D%E7%AB%AF/2020/032702/","excerpt":"","text":"概述最近完善了一下小程序的评论功能，但是弄完后发现评论时加表情，居然报错了。 问题在完善完我的博客小程序评论功能之后，测试了一番，在评论时添加emoji表情发现他居然报错了，伤心。 原因因为在mysql5.5.3版本以前，utf8编码最大能存储3个字节，而表情是4个字节,所以在评论时将表情存到utf8编码的字段里时就报错了！ 解决方法将mysql升级到5.5.3+版本，将utf-8编码，改成utf8mb4编码，这样添加表情时就不会报错啦！ 一.修改数据库配置文件（my.cnf）1.打开linux，打开文件my.cnf,输入以下命令1vim /etc/my.cnf 2.插入以下代码1234567891011[client] default-character-set=utf8mb4 [mysql] default-character-set=utf8mb4 [mysqld] character-set-client-handshake = FALSE collation-server = utf8mb4_unicode_ci init-connect=&apos;SET NAMES utf8mb4&apos; character-set-server = utf8mb4 注：或者借用xftp找到路径：/etc/my.cnf下编辑也行，输入方法2中的代码： 3.重启mysql服务1service mysql restart 4.进入mysql1mysql -u root -p 5.查看mysql字符集1SHOW VARIABLES WHERE Variable_name LIKE &apos;character\\_set\\_%&apos; OR Variable_name LIKE &apos;collation%&apos;; 然后就可以了： 如果插入表情还是不行，那可能是原有数据库，表，字段已经设计好，而且已经存入过数据，然后存入emoji表情，编码还是原来的utf-8，则可以试下步骤二； 二.修改数据库、表、字段1.查看字符集首先先查看下存储表情的字段是什么字符集： 1SHOW FULL COLUMNS FROM wxmini_user_info 2.修改字符集如果还是utf-8，则说明，步骤一没改变表的字符集，因此我们需要根据需求将存储表情的数据库或表或字段改为utf8mb4编码： 修改数据库字符集： 1ALTER DATABASE 数据库名 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci; 修改表的字符集： 1ALTER TABLE 表名 CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; 修改某个字段的字符集： 1ALTER TABLE 表名 CHANGE 字段名 字段名 该字段原来的数据类型 CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; 注：如果修改的表或字段中存在数据时，应谨慎修改其字符集，操作不当，可能会导致数据丢失； 总结按上面两个步骤修改完，就可以保存emoji表情了，在linux修改my.cnf文件的时，记得备份以防出错不好回滚；还有确定数据库的版本，否则取出的值可能会显示问号。如果存入就是问号，那说明配置没有成功，请重启mysql，或者关闭再启动，再试试； 结果回复插入表情成功，啦啦啦（上面的问号是没改之前的数据）： 其他1.为啥服务设置字符集，还要设置表，设置字段： MySQL中默认字符集的设置有四级:服务器级，数据库级，表级 ，还有字段级的字符集设置。前三种均为默认设置，并不代码你的字段最终会使用这个字符集设置。因此在使用mysql时，字符集都是已经设定好的，系统会确定默认所使用的字符集和校对规则，也就是说如果没有对更低级别的字符集和校对规则进行设置时，字符集会默认继承更高级别所设定的默认字符集和校对规则，可能会影响我们储存数据，所以我们建议要用show create table table ; 或show full fields from tableName; 先来检查当前表中字段的字符集设置。2.utf8与utf8mb4哪个好： utf8mb4是utf8的超集，除了将编码改为utf8mb4外不需要做其他转换。 utf8mb4编码中mb4就是most bytes 4的意思，专门用来兼容四字节的unicode。他们之间的区别就是mysql支持的 utf8 编码最大字符长度为 3 字节，如果遇到 4 字节的宽字符就会插入异常了。三个字节的utf8最大能编码的Unicode字符是 0xffff，也就是说，任何不在基本多文本平面的 Unicode字符，都无法使用 Mysql 的 utf8 字符集存储，包括 emoji 表情等；所以，设计数据库时如果想要允许用户使用特殊符号，最好使用utf8mb4编码来存储，使得数据库有更好的兼容性，但是这样设计会导致耗费更多的存储空间。参考文档: utf8和utf8mb4的具体区别有哪些？","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"Java入坑01-Java入门简介","slug":"后端/2020/031201","date":"2020-03-11T16:00:00.000Z","updated":"2020-09-25T03:04:27.409Z","comments":true,"path":"2020/03/12/后端/2020/031201/","link":"","permalink":"http://yoursite.com/2020/03/12/%E5%90%8E%E7%AB%AF/2020/031201/","excerpt":"","text":"概述java学习笔记，教程:廖雪峰官方网站; 一.Java的三个版本1.JavaSE：Standard Edition，标准版，包含标准的JVM和标准库； 2.JavaEE：Enterprise Edition，在Java SE的基础上加上了大量的API和库，以便方便开发Web应用、数据库、消息服务等； 3.JavaME：Micro Edition，一个针对嵌入式设备的javaSE的简洁版； 三者间的关系： 二.学习路线1.Java SE：掌握Java语言本身、Java核心开发技术以及Java标准库的使用； 2.Java EE：Spring框架、数据库开发、分布式架构； 三.安装jdk什么是jdk，为什么要安装jdk因为Java程序必须运行在JVM之上，如果只有Java源码，要编译成Java字节码，就需要jdk，因为jdk除了包含jre(运行Java字节码的虚拟机)，还提供了编译器、调试器等开发工具。 jdk安装步骤：https://www.btluo.com/news.html?articleId=55 四.编写第一个java程序1.新建一个文件夹，新增一个.java格式的文件，如下图所示： 2.打开编辑器，将刚刚新建的文件打开，输入我们的第一个java程序代码： 12345public class Hello &#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello, world!&quot;); &#125;&#125; 在上面java程序中的： public class Hello{...}这种写法被定义为class类，public表示这个类是公开的，class用来定义这是一个类，public、class都是Java的关键字，必须小写，Hello是类的名字，首字母H要大写。而花括号{}中间则是类的定义； 在花括号{}中，Hello类定义了一个名为main的方法： public static void main(String[] args) { ... }它是可执行的代码块，一个方法除了方法名main，还有用()括起来的方法参数，这里的main方法有一个参数，参数类型是String[]，参数名是args，public、static用来修饰方法，这里表示它是一个公开的静态方法，void是方法的返回类型，而花括号{}中间的就是方法的代码；方法里的代码每一行用;结束，这里只有一行代码，就是： System.out.println(&quot;Hello, world!&quot;);意思是打印Hello, world!到控制台； Java规定，每个类定义的public static void main(String[] args)是Java程序的固定入口方法，因此，Java程序总是从main方法开始执行。 3.运行java代码： Java源码本质上是一个文本文件，我们需要先用javac把Hello.java编译成字节码文件Hello.class，然后，用java命令执行这个字节码文件： 所以通过javac执行Hello.java文件，生成Hello.css文件 在执行以下命令,就能输出刚刚需要打印的Hello, world!了： java Hello 注： 一个Java源码只能定义一个public类型的class，并且class名称和文件名要完全一致； 使用javac可以将.java源码编译成.class字节码； 使用java可以运行一个已编译的Java程序，参数是类名。 系列文章皆摘抄至：廖雪峰的官方网站","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Java入坑02-eclipse安装及配置使用","slug":"后端/2020/031202","date":"2020-03-11T16:00:00.000Z","updated":"2020-09-25T03:04:27.409Z","comments":true,"path":"2020/03/12/后端/2020/031202/","link":"","permalink":"http://yoursite.com/2020/03/12/%E5%90%8E%E7%AB%AF/2020/031202/","excerpt":"","text":"概述java学习笔记，教程:廖雪峰官方网站; Java开发，其实在安装好JDK后，就可以使用文本文档编辑，但是这样开发十分麻烦，效率极低。因此需要使用专门的开发工具，辅助我们快速、高效地开发代码。目前比较流行的Java开发工具有三个：Eclipse、MyEclipse、IntelliJ IDEA。以下是Eclipse的安装和JDK的整合： 一.Eclipse的安装1.打开eclipse的官网：https://www.eclipse.org/downloads/packages/ 点击Download下载： 下载完后点击安装： 二.为Eclipse配置JDK1、打开Eclipse，点击菜单栏Window下的Preferences。 2.点击Java–》Instralled JREs–》Add，选择默认standard VM–》next，选择JDK安装的位置，点击完成。最后点击Apply，完成JDK配置。 选择jdk所在文件夹: 点击Apply，配置完成： 三.其他设置1.General –》 Editors –》 Text Editors： 钩上“Show line numbers”，这样编辑器会显示行号； 2.General –》 Workspace: 钩上“Refresh using native hooks or polling”，这样Eclipse会自动刷新文件夹的改动； 对于“Text file encoding”，如果Default不是UTF-8，一定要改为“Other：UTF-8”，所有文本文件均使用UTF-8编码； 对于“New text file line delimiter”，建议使用Unix，即换行符使用\\n而不是Windows的\\r\\n。 3.Windows–》preferences–》Java–》Editor–》Content Assist 在右边的“Auto activation triggers for Java”后的框中输入.qwertyuioplkjhgfdsazxcvbnm，点击OK。 设置成功后可自动补全代码； 四.使用eclipse新建java项目1.在Eclipse菜单选择File–》New–》Java Project，给项目命名，如HelloWord： 点击“Finish”就成功创建了一个名为HelloWorld的Java工程。 2.新建并运行HelloWorld： 选中源码目录src，点击右键，在弹出菜单中选择New–》Class： 输入要输出的测试内容：System.out.println(“Hello Word”)， 保存，然后选中文件Hello.java，点击右键，在弹出的菜单中选中Run As–》Java Application： 在Console窗口中就可以看到运行结果： 如果没有在主界面中看到Console窗口，请选中菜单Window–》Show View–》Console，即可显示。","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"java入坑03-廖雪峰官网练习插件","slug":"后端/2020/031203","date":"2020-03-11T16:00:00.000Z","updated":"2020-09-25T03:04:27.409Z","comments":true,"path":"2020/03/12/后端/2020/031203/","link":"","permalink":"http://yoursite.com/2020/03/12/%E5%90%8E%E7%AB%AF/2020/031203/","excerpt":"","text":"概述java学习笔记，教程:廖雪峰官方网站; 本文是廖雪峰官网提供的一个Eclipse IDE的练习插件，可以非常方便地下载练习代码。 正文1.选择Help–》Install New Software，Add新增插件： 输入任意名称，如Java Practice Plugin，填入https://liaoxuefeng.gitee.io/learn-java-update-site/，然后Add： 在列表中选中Java Practice Feature，然后点击Next安装： 在安装过程中，由于插件代码没有数字签名，所以会弹出一个警告，选择Install anyway继续安装，安装成功后，根据提示重启Eclipse即可。 重启Eclipse后，选择菜单Window–》Show View–》Other，在弹出的对话框中选择Java–》Java Practice： 然后点击打开，即可在Eclipse中看到Java Practice插件： 双击右侧hello.zip直接下载并导入到Eclipse中，即可打开对应练习；","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"在vue中添加浏览器导航标题favicon图标","slug":"前端/2020/010601","date":"2020-01-05T16:00:00.000Z","updated":"2020-09-25T03:04:27.403Z","comments":true,"path":"2020/01/06/前端/2020/010601/","link":"","permalink":"http://yoursite.com/2020/01/06/%E5%89%8D%E7%AB%AF/2020/010601/","excerpt":"","text":"概述vue在打包时添加favicon标题图标文件方法 方法修改webpack中的配置文件： 1.将favicon.ico图片放在根目录下； 2.找到build下的webpack.dev.conf.js文件找到以下内容，新增favicon: path.resolve(‘favicon.ico’)： 123456new HtmlWebpackPlugin(&#123; filename: &apos;index.html&apos;, template: &apos;index.html&apos;, inject: true, favicon: path.resolve(&apos;favicon.ico&apos;)//新增内容&#125;), 3.找到build下的webpack.prod.conf.js文件，找到以下内容，并新增 favicon: path.resolve(‘favicon.ico’)： 123456789101112new HtmlWebpackPlugin(&#123; filename: config.build.index, template: &apos;index.html&apos;, inject: true, favicon: path.resolve(&apos;favicon.ico&apos;), //新增内容 minify: &#123; removeComments: true, collapseWhitespace: true, removeAttributeQuotes: true &#125;, chunksSortMode: &apos;dependency&apos;&#125;), 4.在首页index.html中引入favicon.ico： 1&lt;link rel=&quot;shortcut icon&quot; type=&quot;image/x-icon&quot; href=&quot;favicon.ico&quot;/&gt; 5.重新打包： 1npm run build 就能在打包文件dist中看到favicon.ico文件了； 当然也可以直接将favicon.ico文件放在dist的根目录中，直接在index.html中引入就行，但是这样每次打包都得复制favicon.ico到根目录，不推荐这种方法。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"微信小程序-如何直接上传文件到腾讯云","slug":"前端/2019/122801","date":"2019-12-27T16:00:00.000Z","updated":"2020-09-25T03:04:27.402Z","comments":true,"path":"2019/12/28/前端/2019/122801/","link":"","permalink":"http://yoursite.com/2019/12/28/%E5%89%8D%E7%AB%AF/2019/122801/","excerpt":"","text":"概述在开发小程序的过程中有多处页面使用了图片上传的功能，为了减少服务器的压力，建议还是上传到腾讯云，阿里云或者千牛云等其他平台上来存储我们的图片。 一.背景当使用小程序上传文件时，服务器接口需要对上传文件进行处理，如果同一时间访问量大的话，后台要先处理请求，在把上传的文件存放到指定的文件夹里，在返回给客服端结果，处理的速度相对是比较慢的，用户等待的时间也就比较长，体验感不好。 如果我们在上传文件时直接上传到云服务器（腾讯云，阿里云，七牛云等）上，我们就可以直接把这个上传返回的可访问的文件地址在前端拿到，然后后端接收直接存入数据库就行，处理的时间就大大的减少了。 二.目录结构 三.主要文件12345config.js----配置腾讯云信息；cos-wx-sdk-v5.js----微信小程序SDK 腾讯云对象存储服务；sdk.js----封装的返回文件路径接口；util.js----更改文件名时用于获取时间戳；uploadToCos文件夹----测试demo:上传图片至腾讯云； 四.uploadToCos效果图 五.实现步骤1.config.js–配置腾讯云信息; 1234567var config = &#123; Bucket: &quot;**********&quot;, Region: &quot;ap-******&quot;, SecretId: &quot;*******************&quot;, SecretKey: &quot;********************&quot;&#125;module.exports = config; 注意将*替换成自己从腾讯云获取的配置信息（配置信息最好通过后台请求接口返回在放入config.js）。 腾讯云对象存储：https://cloud.tencent.com/document/product/436/7751 2.cos-wx-sdk-v5.js–微信小程序SDK for 腾讯云对象存储服务; cos-wx-sdk-v5快速入门：https://www.npmjs.com/package/cos-wx-sdk-v5 3.sdk.js–封装的返回文件路径接口; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960var util = require(&quot;../utils/util.js&quot;);var COS = require(&quot;../utils/cos-wx-sdk-v5.js&quot;);var config = require(&quot;../utils/config.js&quot;);var cos = new COS(&#123; getAuthorization: function (params, callback) &#123;//获取签名 必填参数 // 方法一（推荐）服务器提供计算签名的接口 // wx.request(&#123; // url: &quot;SIGN_SERVER_URL&quot;, // data: &#123; // Method: params.Method, // Key: params.Key // &#125;, // dataType: &quot;text&quot;, // success: function (result) &#123; // callback(result.data); // &#125; // &#125;); // 方法二（适用于前端调试） var authorization = COS.getAuthorization(&#123; SecretId: config.SecretId, SecretKey: config.SecretKey, Method: params.Method, Key: params.Key &#125;); callback(authorization); &#125;&#125;);function sdk(filePath) &#123; return new Promise(function (resolve, reject) &#123; let nowTime = util.formatTime(new Date()); // 上传的文件名 let Key = &quot;album/&quot; + nowTime + &quot;/&quot; + filePath.substr(filePath.lastIndexOf(&quot;/&quot;) + 1); cos.postObject(&#123; Bucket: config.Bucket, Region: config.Region, Key: Key, FilePath: filePath, onProgress: function (info) &#123; // 上传进度 // console.log(info); &#125; &#125;, function (err, data) &#123; // console.log(err); // console.log(data); let res; if (data &amp;&amp; data.headers.Location) &#123; res =&#123;code:0,data: data.headers.Location&#125; resolve(res); &#125; else &#123; // 记得更换config里的腾讯云配置，否则就会执行下面代码 res = &#123;code: 400,msg: &quot;文件上传失败，请重试&quot;&#125; resolve(res); &#125; &#125;); &#125;);&#125;module.exports = &#123; sdk&#125; 4.util.js–更改文件名时用于获取时间戳; 1234567891011121314151617181920212223242526272829303132333435363738const formatTime = date =&gt; &#123; const year = date.getFullYear() const month = date.getMonth() + 1 const day = date.getDate() const hour = date.getHours() const minute = date.getMinutes() const second = date.getSeconds() return [year, month, day].map(formatNumber).join(&apos;/&apos;) // + &apos; &apos; + [hour, minute, second].map(formatNumber).join(&apos;:&apos;)&#125;const formatNumber = n =&gt; &#123; n = n.toString() return n[1] ? n : &apos;0&apos; + n&#125;// 消息提示function showErrorToast(msg) &#123; wx.showToast(&#123; title: msg, icon: &apos;loading&apos;, &#125;)&#125;// 错误提示function showErrorModal(msg) &#123; wx.showModal(&#123; title: &apos;温馨提示&apos;, content: msg, showCancel: false &#125;)&#125;module.exports = &#123; formatTime, showErrorToast, showErrorModal,&#125; 5.uploadToCos文件夹html: 1234567891011121314151617181920212223&lt;view class=&quot;videoBox&quot;&gt; &lt;view class=&quot;space&quot;&gt;&lt;/view&gt; &lt;view class=&quot;videoBody flex ac&quot;&gt; &lt;view class=&quot;uploadBox&quot;&gt; &lt;image class=&quot;imgBtn&quot; src=&quot;/images/nestEdgeImg.jpg&quot; mode=&quot;aspectFill&quot; bindtap=&quot;chooseWxImage&quot; wx:if=&quot;&#123;&#123;imgUrl == &apos;&apos;&#125;&#125;&quot;&gt;&lt;/image&gt; &lt;image class=&quot;imgBtn&quot; src=&quot;&#123;&#123;imgUrl&#125;&#125;&quot; mode=&quot;aspectFill&quot; bindtap=&quot;imgPreview&quot; wx:else&gt;&lt;/image&gt; &lt;view class=&quot;delImg&quot; wx:if=&quot;&#123;&#123;imgUrl != &apos;&apos;&#125;&#125;&quot; data-type=&quot;img&quot; bindtap=&quot;delUpload&quot;&gt; &lt;image src=&quot;/images/nestEdgeClose.png&quot;&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;uploadBox&quot;&gt; &lt;image class=&quot;imgBtn&quot; src=&quot;/images/nestEdgeVideo.jpg&quot; mode=&quot;aspectFill&quot; bindtap=&quot;chooseWxVideo&quot; wx:if=&quot;&#123;&#123;videoUrl == &apos;&apos;&#125;&#125;&quot;&gt;&lt;/image&gt; &lt;video src=&quot;&#123;&#123;videoUrl&#125;&#125;&quot; poster=&quot;&#123;&#123;imgUrl&#125;&#125;&quot; wx:else&gt;&lt;/video&gt; &lt;view class=&quot;delImg&quot; wx:if=&quot;&#123;&#123;videoUrl != &apos;&apos;&#125;&#125;&quot; data-type=&quot;video&quot; bindtap=&quot;delUpload&quot;&gt; &lt;image src=&quot;/images/nestEdgeClose.png&quot;&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;prompt f24 c888&quot;&gt;提示：点击上传图片或视频&lt;/view&gt; &lt;view class=&quot;videoFoot&quot;&gt; &lt;button class=&quot;btnMain&quot; bindtap=&quot;completeUpload&quot;&gt;完成&lt;/button&gt; &lt;/view&gt;&lt;/view&gt; css： 12345678910.videoBox&#123;width: 100%;overflow: hidden;&#125;.videoBox .videoBody&#123;padding: 40rpx;&#125;.videoBox .videoBody .uploadBox&#123;width: 210rpx; height: 210rpx; border: 1px dashed #cecece; border-radius: 10rpx; margin-right: 30rpx;position: relative;&#125;.videoBox .videoBody .uploadBox .imgBtn&#123;width: 100%; height: 100%;&#125;.videoBox .videoBody .uploadBox .delImg&#123;position: absolute;top: -20rpx;right: -20rpx;&#125;.videoBox .videoBody .uploadBox .delImg image&#123;width: 40rpx;height: 40rpx;&#125;.videoBox .videoBody .uploadBox video&#123;width: 100%; height: 100%;&#125;.videoBox .prompt&#123;padding: 0 40rpx;&#125;.videoBox .videoFoot&#123;margin-top: 120rpx;&#125;.videoBox .videoFoot button&#123;width: 92%; margin: 0 4%;height: 90rpx;line-height: 90rpx;&#125; js： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134var util = require(&quot;../../utils/util.js&quot;);var sdk = require(&quot;../../utils/sdk.js&quot;);Page(&#123; /** * 页面的初始数据 * imgUrl：视频封面 * videoUrl：视频路径 */ data: &#123; imgUrl: &quot;&quot;, videoUrl: &quot;&quot; &#125;, // 图片本地路径 chooseWxImage: function (type) &#123; let that = this; wx.chooseImage(&#123; count: 1, // 最多可以选择的图片张数，默认9 sizeType: [&quot;original&quot;, &quot;compressed&quot;], // original 原图，compressed 压缩图，默认二者都有 sourceType: [&quot;album&quot;, &quot;camera&quot;], // album 从相册选图，camera 使用相机，默认二者都有 success: function (res) &#123; let filePath = res.tempFilePaths[0]; wx.showLoading(&#123; title: &quot;图片上传中&quot;, mask: true &#125;); sdk.sdk(filePath).then(res =&gt; &#123; console.log(res); if (res.code == 0) &#123; wx.hideLoading(); that.setData(&#123; imgUrl: res.data &#125;) &#125; else &#123; wx.hideLoading(); wx.showModal(&#123; title: &quot;温馨提示&quot;, content: res.msg, showCancel: false, success: function () &#123; that.setData(&#123; imgUrl: &quot;&quot; &#125;) &#125; &#125;) &#125; &#125;) &#125;, &#125;); &#125;, //图片预览 imgPreview: function (event) &#123; let that = this , src = this.data.imgUrl , imgList = [src];//获取data-list //图片预览 wx.previewImage(&#123; current: src, // 当前显示图片的http链接 urls: imgList // 需要预览的图片http链接列表 &#125;) &#125;, // 添加视频 chooseWxVideo: function () &#123; let that = this; wx.chooseVideo(&#123; sourceType: [&quot;album&quot;, &quot;camera&quot;], maxDuration: 60, camera: &quot;back&quot;, success(res) &#123; let filePath = res.tempFilePath; wx.showLoading(&#123; title: &quot;视频上传中&quot;, mask: true &#125;); sdk.sdk(filePath).then(res =&gt; &#123; console.log(res); if (res.code == 0) &#123; wx.hideLoading(); that.setData(&#123; videoUrl: res.data &#125;) &#125; else &#123; wx.hideLoading(); wx.showModal(&#123; title: &quot;温馨提示&quot;, content: res.msg, showCancel: false, success: function () &#123; that.setData(&#123; videoUrl: &quot;&quot; &#125;) &#125; &#125;) &#125; &#125;) &#125; &#125;) &#125;, // 删除图片或视频 delUpload: function (e) &#123; console.log(e.currentTarget.dataset.type); let that = this , type = e.currentTarget.dataset.type; if (type == &quot;img&quot;) &#123; that.setData(&#123; imgUrl: &quot;&quot; &#125;) &#125; else if (type == &quot;video&quot;) &#123; that.setData(&#123; videoUrl: &quot;&quot; &#125;) &#125; else &#123; util.showErrorModal(&quot;删除失败，请重试！&quot;); &#125; &#125;, // 完成视频编辑 completeUpload: function () &#123; let that = this , imgUrl = this.data.imgUrl , videoUrl = this.data.videoUrl; if (imgUrl == &quot;&quot;) &#123; util.showErrorModal(&quot;请上传视频封面！&quot;); return false; &#125; if (videoUrl == &quot;&quot;) &#123; util.showErrorModal(&quot;请上传视频！&quot;); return false; &#125; wx.showModal(&#123; title: &quot;温馨提示&quot;, content: &quot;请求成功！&quot;, showCancel: false, success: function () &#123; wx.redirectTo(&#123; url: &quot;/pages/index/index&quot;, &#125;) &#125; &#125;) &#125;,&#125;) 项目案例下载地址：https://gitee.com/caseAddress/wxminiDemo.git –其他小程序插件共用地址，持续更新中 参考文章：https://github.com/piscium2010/cos-wx-upload-file","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}]},{"title":"vue整合wangeditor3富文本编辑器","slug":"前端/2019/122601","date":"2019-12-25T16:00:00.000Z","updated":"2020-09-25T03:04:27.402Z","comments":true,"path":"2019/12/26/前端/2019/122601/","link":"","permalink":"http://yoursite.com/2019/12/26/%E5%89%8D%E7%AB%AF/2019/122601/","excerpt":"","text":"概述在使用vue做管理后台时，编辑文章页面需要使用到富文本编辑器，因此本文主要介绍如何在vue中添加wangeditor3编辑器 一.背景由于在开发管理后台的时候编辑文章，轮播等可能会多个页面需要用到富文本编辑器，因此，我需要将wangeditor作为组件的形式整合到vue中使用； 二.实现步骤1.安装wangEditor1npm install wangeditor --save 2.封装组件将wangEditor封装成组件wangeditor.vue（子组件）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;template&gt; &lt;div id=&quot;wangeditor&quot;&gt; &lt;div ref=&quot;editorElem&quot; style=&quot;text-align:left&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import E from &quot;wangeditor&quot;;export default &#123; name: &quot;editorElem&quot;, data() &#123; return &#123; editor: null, editorContent: &quot;&quot; &#125;; &#125;, props: [&quot;catchData&quot;, &quot;content&quot;], // 接收父组件的方法 watch: &#123; content() &#123; this.editor.txt.html(this.content); &#125; &#125;, mounted() &#123; this.editor = new E(this.$refs.editorElem); this.editor.customConfig.onchange = html =&gt; &#123; this.editorContent = html; this.catchData(this.editorContent); // 把这个html通过catchData的方法传入父组件 &#125;; this.editor.customConfig.uploadImgServer = &quot;你的上传图片的接口&quot;; this.editor.customConfig.uploadFileName = &quot;你自定义的文件名&quot;; this.editor.customConfig.menus = [&quot;undo&quot;,&quot;redo&quot;,&quot;bold&quot;,&quot;italic&quot;,&quot;underline&quot;,&quot;strikeThrough&quot;,&quot;link&quot;,&quot;quote&quot;,&quot;image&quot;,&quot;emoticon&quot;,&quot;table&quot;,&quot;video&quot;,&quot;head&quot;,&quot;fontSize&quot;,&quot;fontName&quot;,&quot;foreColor&quot;,&quot;backColor&quot;,&quot;list&quot;,&quot;justify&quot;,&quot;code&quot;]; // 下面是最重要的的方法 this.editor.customConfig.uploadImgHooks = &#123; before: function(xhr, editor, files) &#123; // 图片上传之前触发 // xhr 是 XMLHttpRequst 对象，editor 是编辑器对象，files 是选择的图片文件 // 如果返回的结果是 &#123;prevent: true, msg: &apos;xxxx&apos;&#125; 则表示用户放弃上传 // return &#123; // prevent: true, // msg: &apos;放弃上传&apos; // &#125; &#125;, success: function(xhr, editor, result) &#123; // 图片上传并返回结果，图片插入成功之后触发 // xhr 是 XMLHttpRequst 对象，editor 是编辑器对象，result 是服务器端返回的结果 this.imgUrl = Object.values(result.data).toString(); &#125;, fail: function(xhr, editor, result) &#123; // 图片上传并返回结果，但图片插入错误时触发 // xhr 是 XMLHttpRequst 对象，editor 是编辑器对象，result 是服务器端返回的结果 &#125;, error: function(xhr, editor) &#123; // 图片上传出错时触发 // xhr 是 XMLHttpRequst 对象，editor 是编辑器对象 &#125;, timeout: function(xhr, editor) &#123; // 图片上传超时时触发 // xhr 是 XMLHttpRequst 对象，editor 是编辑器对象 &#125;, // 如果服务器端返回的不是 &#123;errno:0, data: [...]&#125; 这种格式，可使用该配置 // （但是，服务器端返回的必须是一个 JSON 格式字符串！！！否则会报错） customInsert: function(insertImg, result, editor) &#123; // 图片上传并返回结果，自定义插入图片的事件（而不是编辑器自动插入图片！！！） // insertImg 是插入图片的函数，editor 是编辑器对象，result 是服务器端返回的结果 // 举例：假如上传图片成功后，服务器端返回的是 &#123;url:&apos;....&apos;&#125; 这种格式，即可这样插入图片： let url = Object.values(result.data); // result.data就是服务器返回的图片名字和链接 JSON.stringify(url); // 在这里转成JSON格式 insertImg(url); // result 必须是一个 JSON 格式字符串！！！否则报错 &#125; &#125;; this.editor.create(); // 创建富文本实例 if (!this.content) &#123; this.editor.txt.html(&quot;请输入编辑内容&quot;); &#125;else&#123; this.editor.txt.html(this.content); &#125; &#125;&#125;;&lt;/script&gt;&lt;style lang=&quot;scss&quot; rel=&quot;stylesheet/scss&quot;&gt; #wangeditor &#123; width: 100%; &#125; #wangeditor .w-e-toolbar &#123; flex-wrap: wrap; &#125;&lt;/style&gt; 3.在父组件中调用子组件①.引入子组件(注意改成自己的子组件存放路径)： 1import wangeditor from &quot;../../components/wangeditor&quot;; ②.在components 中注册子组件： 123components: &#123; wangeditor: wangeditor&#125; ③.监听富文本编辑器输入内容： 123catchData(value) &#123; this.content = value;&#125; 步骤①，②，③完整代码： 12345678910111213141516171819&lt;script&gt;import wangeditor from &quot;../../components/wangeditor&quot;;export default &#123; data() &#123; return &#123;&#125;; &#125;, methods: &#123; // 监听富文本编辑器 catchData(value) &#123; this.content = value; &#125;, &#125;, components: &#123; wangeditor: wangeditor &#125;, mounted() &#123; &#125;&#125;;&lt;/script&gt; ④.在模板中渲染： 1&lt;wangeditor :catchData=&quot;catchData&quot; :content=&quot;editForm.content&quot;&gt;&lt;/wangeditor&gt; 在子组件中用props 项传了两个值，一个catchData函数，在methods中定义步骤③，用于在父组件中获取富文本中的内容，还有一个content作为初始化的数据（用于初始化从后台获取到的文章内容）； editForm.content的内容根据实际代码替换成后台返回的数据； 三.其他wangeditor官网：http://www.wangeditor.com","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}]},{"title":"Java-JDK下载与安装详细步骤","slug":"后端/2019/122001","date":"2019-12-19T16:00:00.000Z","updated":"2020-09-25T03:04:27.408Z","comments":true,"path":"2019/12/20/后端/2019/122001/","link":"","permalink":"http://yoursite.com/2019/12/20/%E5%90%8E%E7%AB%AF/2019/122001/","excerpt":"","text":"概述后台在运行Java源码时，要编译成Java字节码，就需要JDK，因为JDK除了包含JRE，还提供了编译器、调试器等开发工具。 1.下载并安装jdk官方下载地址：https://www.oracle.com/technetwork/java/javase/downloads/index.html 2.配置环境变量①.右击桌面“我的电脑”右键–&gt;”属性”–&gt;”高级系统设置”–&gt;”高级”–&gt;”环境变量” ; ②.在系统变量里新建”JAVA_HOME”变量，变量值为： 1D:\\Program Files\\Java\\jdk1.8.0_131（安装jdk时所在安装路径） ③.在系统变量里新建”classpath”变量，输入（最前面的.不要漏了）： 1.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar;%JAVA_HOME%\\lib\\dt.jar ④.找到path变量，添加变量值（已存在就不用新建）： 1%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin ⑤.打开命令行，输入以下命令，测试配置是否成功： 1java -version 1javac","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"js获取用户访问IP，城市，以及获取当前操作浏览器","slug":"前端/2019/121801","date":"2019-12-17T16:00:00.000Z","updated":"2020-09-25T03:04:27.402Z","comments":true,"path":"2019/12/18/前端/2019/121801/","link":"","permalink":"http://yoursite.com/2019/12/18/%E5%89%8D%E7%AB%AF/2019/121801/","excerpt":"","text":"概述在管理后台，异地登录和对用户常用浏览器做数据分析时，常常会用到访问IP，当前操作浏览器等，因此本文主要介绍怎么获取IP,城市以及浏览器 1.引入搜狐IP地址查询接口1&lt;script src=&quot;https://pv.sohu.com/cityjson?ie=utf-8&quot;&gt;&lt;/script&gt; 2.写入获取当前操作浏览器函数1234567891011121314151617181920212223function getBrowserInfo() &#123; var agent = navigator.userAgent.toLowerCase(); var regStr_ie = /msie [\\d.]+;/gi; var regStr_ff = /firefox\\/[\\d.]+/gi var regStr_chrome = /chrome\\/[\\d.]+/gi; var regStr_saf = /safari\\/[\\d.]+/gi; //IE if (agent.indexOf(&quot;msie&quot;) &gt; 0) &#123; return agent.match(regStr_ie); &#125; //firefox if (agent.indexOf(&quot;firefox&quot;) &gt; 0) &#123; return agent.match(regStr_ff); &#125; //Chrome if (agent.indexOf(&quot;chrome&quot;) &gt; 0) &#123; return agent.match(regStr_chrome); &#125; //Safari if (agent.indexOf(&quot;safari&quot;) &gt; 0 &amp;&amp; agent.indexOf(&quot;chrome&quot;) &lt; 0) &#123; return agent.match(regStr_saf); &#125;&#125; 或： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195// 获取访问IP、地区、、当前操作浏览器var BrowserMatch = &#123; init: function () &#123; this.browser = this.getBrowser().browser || &quot;未知浏览器&quot;; //获取浏览器名 this.version = this.getBrowser().version || &quot;未知浏览器版本号&quot;; //获取浏览器版本 this.OS = this.getOS() + &quot; &quot; + this.getDigits() || &quot;未知操作系统&quot;; //系统版本号 &#125;, getOS: function () &#123; //判断所处操作系统 var sUserAgent = navigator.userAgent.toLowerCase(); var isWin = (navigator.platform == &quot;Win32&quot;) || (navigator.platform == &quot;Win64&quot;) || (navigator.platform == &quot;wow64&quot;); var isMac = (navigator.platform == &quot;Mac68K&quot;) || (navigator.platform == &quot;MacPPC&quot;) || (navigator.platform == &quot;Macintosh&quot;) || (navigator.platform == &quot;MacIntel&quot;); if (isMac) return &quot;Mac&quot;; var isUnix = (navigator.platform == &quot;X11&quot;) &amp;&amp; !isWin &amp;&amp; !isMac; if (isUnix) return &quot;Unix&quot;; var isLinux = (String(navigator.platform).indexOf(&quot;Linux&quot;) &gt; -1); var bIsAndroid = sUserAgent.toLowerCase().match(/android/i) == &quot;android&quot;; if (isLinux) &#123; if (bIsAndroid) return &quot;Android&quot;; else return &quot;Linux&quot;; &#125; if (isWin) &#123; var isWin2K = sUserAgent.indexOf(&quot;Windows nt 5.0&quot;) &gt; -1 || sUserAgent.indexOf(&quot;Windows 2000&quot;) &gt; -1; if (isWin2K) return &quot;Win2000&quot;; var isWinXP = sUserAgent.indexOf(&quot;Windows nt 5.1&quot;) &gt; -1 || sUserAgent.indexOf(&quot;Windows XP&quot;) &gt; -1 sUserAgent.indexOf(&quot;Windows XP&quot;) &gt; -1; if (isWinXP) return &quot;WinXP&quot;; var isWin2003 = sUserAgent.indexOf(&quot;Windows nt 5.2&quot;) &gt; -1 || sUserAgent.indexOf(&quot;Windows 2003&quot;) &gt; -1; if (isWin2003) return &quot;Win2003&quot;; var isWinVista = sUserAgent.indexOf(&quot;Windows nt 6.0&quot;) &gt; -1 || sUserAgent.indexOf(&quot;Windows Vista&quot;) &gt; -1; if (isWinVista) return &quot;WinVista&quot;; var isWin7 = sUserAgent.indexOf(&quot;Windows nt 6.1&quot;) &gt; -1 || sUserAgent.indexOf(&quot;Windows 7&quot;) &gt; -1; if (isWin7) return &quot;Win7&quot;; var isWin8 = sUserAgent.indexOf(&quot;windows nt 6.2&quot;) &gt; -1 || sUserAgent.indexOf(&quot;Windows 8&quot;) &gt; -1; if (isWin8) return &quot;Win8&quot;; var isWin10 = sUserAgent.indexOf(&quot;windows nt 10.0&quot;) &gt; -1 || sUserAgent.indexOf(&quot;Windows 10&quot;) &gt; -1; if (isWin10) return &quot;Win10&quot;; &#125; return &quot;其他&quot;; &#125;, getDigits: function () &#123; //判断当前操作系统的版本号 var sUserAgent = navigator.userAgent.toLowerCase(); var is64 = sUserAgent.indexOf(&quot;win64&quot;) &gt; -1 || sUserAgent.indexOf(&quot;wow64&quot;) &gt; -1; if (is64) &#123; return &quot;64位&quot;; &#125; else &#123; return &quot;32位&quot;; &#125; &#125;, getBrowser: function () &#123; // 获取浏览器名 var rMsie = /(msie\\s|trident\\/7)([\\w\\.]+)/; var rTrident = /(trident)\\/([\\w.]+)/; var rEdge = /(chrome)\\/([\\w.]+)/;//IE var rFirefox = /(firefox)\\/([\\w.]+)/; //火狐 var rOpera = /(opera).+version\\/([\\w.]+)/; //旧Opera var rNewOpera = /(opr)\\/(.+)/; //新Opera 基于谷歌 var rChrome = /(chrome)\\/([\\w.]+)/; //谷歌 var rUC = /(chrome)\\/([\\w.]+)/;//UC var rMaxthon = /(chrome)\\/([\\w.]+)/;//遨游 var r2345 = /(chrome)\\/([\\w.]+)/;//2345 var rQQ = /(chrome)\\/([\\w.]+)/;//QQ //var rMetasr = /(metasr)\\/([\\w.]+)/;//搜狗 var rSafari = /version\\/([\\w.]+).*(safari)/; var ua = navigator.userAgent.toLowerCase(); var matchBS, matchBS2; //IE 低版 matchBS = rMsie.exec(ua); if (matchBS != null) &#123; matchBS2 = rTrident.exec(ua); if (matchBS2 != null) &#123; switch (matchBS2[2]) &#123; case &quot;4.0&quot;: return &#123; browser: &quot;Microsoft IE&quot;, version: &quot;IE: 8&quot; //内核版本号 &#125;; break; case &quot;5.0&quot;: return &#123; browser: &quot;Microsoft IE&quot;, version: &quot;IE: 9&quot; &#125;; break; case &quot;6.0&quot;: return &#123; browser: &quot;Microsoft IE&quot;, version: &quot;IE: 10&quot; &#125;; break; case &quot;7.0&quot;: return &#123; browser: &quot;Microsoft IE&quot;, version: &quot;IE: 11&quot; &#125;; break; default: return &#123; browser: &quot;Microsoft IE&quot;, version: &quot;Undefined&quot; &#125;; &#125; &#125; else &#123; return &#123; browser: &quot;Microsoft IE&quot;, version: &quot;IE:&quot; + matchBS[2] || &quot;0&quot; &#125;; &#125; &#125; //IE最新版 matchBS = rEdge.exec(ua); if ((matchBS != null) &amp;&amp; (!(window.attachEvent))) &#123; return &#123; browser: &quot;Microsoft Edge&quot;, version: &quot;Chrome/&quot; + matchBS[2] || &quot;0&quot; &#125;; &#125; //UC浏览器 matchBS = rUC.exec(ua); if ((matchBS != null) &amp;&amp; (!(window.attachEvent))) &#123; return &#123; browser: &quot;UC&quot;, version: &quot;Chrome/&quot; + matchBS[2] || &quot;0&quot; &#125;; &#125; //火狐浏览器 matchBS = rFirefox.exec(ua); if ((matchBS != null) &amp;&amp; (!(window.attachEvent))) &#123; return &#123; browser: &quot;火狐&quot;, version: &quot;Firefox/&quot; + matchBS[2] || &quot;0&quot; &#125;; &#125; //Oper浏览器 matchBS = rOpera.exec(ua); if ((matchBS != null) &amp;&amp; (!(window.attachEvent))) &#123; return &#123; browser: &quot;Opera&quot;, version: &quot;Chrome/&quot; + matchBS[2] || &quot;0&quot; &#125;; &#125; //遨游 matchBS = rMaxthon.exec(ua); if ((matchBS != null) &amp;&amp; (!(window.attachEvent))) &#123; return &#123; browser: &quot;遨游&quot;, version: &quot;Chrome/&quot; + matchBS[2] || &quot;0&quot; &#125;; &#125; //2345浏览器 matchBS = r2345.exec(ua); if ((matchBS != null) &amp;&amp; (!(window.attachEvent))) &#123; return &#123; browser: &quot;2345&quot;, version: &quot;Chrome/ &quot; + matchBS[2] || &quot;0&quot; &#125;; &#125; //QQ浏览器 matchBS = rQQ.exec(ua); if ((matchBS != null) &amp;&amp; (!(window.attachEvent))) &#123; return &#123; browser: &quot;QQ&quot;, version: &quot;Chrome/&quot; + matchBS[2] || &quot;0&quot; &#125;; &#125; //Safari（苹果）浏览器 matchBS = rSafari.exec(ua); if ((matchBS != null) &amp;&amp; (!(window.attachEvent)) &amp;&amp; (!(window.chrome)) &amp;&amp; (!(window.opera))) &#123; return &#123; browser: &quot;Safari&quot;, version: &quot;Safari/&quot; + matchBS[1] || &quot;0&quot; &#125;; &#125; //谷歌浏览器 matchBS = rChrome.exec(ua); if ((matchBS != null) &amp;&amp; (!(window.attachEvent))) &#123; matchBS2 = rNewOpera.exec(ua); if (matchBS2 == null) &#123; return &#123; browser: &quot;谷歌&quot;, version: &quot;Chrome/&quot; + matchBS[2] || &quot;0&quot; &#125;; &#125; else &#123; return &#123; browser: &quot;Opera&quot;, version: &quot;opr/&quot; + matchBS2[2] || &quot;0&quot; &#125;; &#125; &#125; &#125;&#125;;BrowserMatch.init(); 3.获取需要的参数12345678console.log(&quot;当前用户IP地址：&quot;);console.log(returnCitySN[&quot;cip&quot;]);console.log(&quot;当前用户所在城市ID：&quot;);console.log(returnCitySN[&quot;cid&quot;]);console.log(&quot;当前用户所在城市：&quot;);console.log(returnCitySN[&quot;cname&quot;]);console.log(&quot;当前使用浏览器版本：&quot;);console.log(getBrowserInfo()); 或： 12345678console.log(&quot;当前用户IP地址：&quot;);console.log(returnCitySN[&quot;cip&quot;]);console.log(&quot;当前用户所在城市ID：&quot;);console.log(returnCitySN[&quot;cid&quot;]);console.log(&quot;当前用户所在城市：&quot;);console.log(returnCitySN[&quot;cname&quot;]);console.log(&quot;当前使用浏览器版本：&quot;);console.log(&quot;浏览器：&quot;+BrowserMatch.browser + &quot;，内核版本：&quot; + BrowserMatch.version + &quot;，操作系统：&quot; + BrowserMatch.OS); 4.完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;js获取用户访问IP，城市，以及获取当前操作浏览器&lt;/title&gt; &lt;script src=&quot;https://pv.sohu.com/cityjson?ie=utf-8&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; function getBrowserInfo() &#123; var agent = navigator.userAgent.toLowerCase(); var regStr_ie = /msie [\\d.]+;/gi; var regStr_ff = /firefox\\/[\\d.]+/gi var regStr_chrome = /chrome\\/[\\d.]+/gi; var regStr_saf = /safari\\/[\\d.]+/gi; //IE if (agent.indexOf(&quot;msie&quot;) &gt; 0) &#123; return agent.match(regStr_ie); &#125; //firefox if (agent.indexOf(&quot;firefox&quot;) &gt; 0) &#123; return agent.match(regStr_ff); &#125; //Chrome if (agent.indexOf(&quot;chrome&quot;) &gt; 0) &#123; return agent.match(regStr_chrome); &#125; //Safari if (agent.indexOf(&quot;safari&quot;) &gt; 0 &amp;&amp; agent.indexOf(&quot;chrome&quot;) &lt; 0) &#123; return agent.match(regStr_saf); &#125; &#125; console.log(&quot;当前用户IP地址：&quot;); console.log(returnCitySN[&quot;cip&quot;]); console.log(&quot;当前用户所在城市ID：&quot;); console.log(returnCitySN[&quot;cid&quot;]); console.log(&quot;当前用户所在城市：&quot;); console.log(returnCitySN[&quot;cname&quot;]); console.log(&quot;当前使用浏览器版本：&quot;); console.log(getBrowserInfo()); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 或： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;js获取用户访问IP，城市，以及获取当前操作浏览器&lt;/title&gt; &lt;script src=&quot;https://pv.sohu.com/cityjson?ie=utf-8&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 获取访问IP、地区、、当前操作浏览器 var BrowserMatch = &#123; init: function () &#123; this.browser = this.getBrowser().browser || &quot;未知浏览器&quot;; //获取浏览器名 this.version = this.getBrowser().version || &quot;未知浏览器版本号&quot;; //获取浏览器版本 this.OS = this.getOS() + &quot; &quot; + this.getDigits() || &quot;未知操作系统&quot;; //系统版本号 &#125;, getOS: function () &#123; //判断所处操作系统 var sUserAgent = navigator.userAgent.toLowerCase(); var isWin = (navigator.platform == &quot;Win32&quot;) || (navigator.platform == &quot;Win64&quot;) || (navigator.platform == &quot;wow64&quot;); var isMac = (navigator.platform == &quot;Mac68K&quot;) || (navigator.platform == &quot;MacPPC&quot;) || (navigator.platform == &quot;Macintosh&quot;) || (navigator.platform == &quot;MacIntel&quot;); if (isMac) return &quot;Mac&quot;; var isUnix = (navigator.platform == &quot;X11&quot;) &amp;&amp; !isWin &amp;&amp; !isMac; if (isUnix) return &quot;Unix&quot;; var isLinux = (String(navigator.platform).indexOf(&quot;Linux&quot;) &gt; -1); var bIsAndroid = sUserAgent.toLowerCase().match(/android/i) == &quot;android&quot;; if (isLinux) &#123; if (bIsAndroid) return &quot;Android&quot;; else return &quot;Linux&quot;; &#125; if (isWin) &#123; var isWin2K = sUserAgent.indexOf(&quot;Windows nt 5.0&quot;) &gt; -1 || sUserAgent.indexOf(&quot;Windows 2000&quot;) &gt; -1; if (isWin2K) return &quot;Win2000&quot;; var isWinXP = sUserAgent.indexOf(&quot;Windows nt 5.1&quot;) &gt; -1 || sUserAgent.indexOf(&quot;Windows XP&quot;) &gt; -1 sUserAgent.indexOf(&quot;Windows XP&quot;) &gt; -1; if (isWinXP) return &quot;WinXP&quot;; var isWin2003 = sUserAgent.indexOf(&quot;Windows nt 5.2&quot;) &gt; -1 || sUserAgent.indexOf(&quot;Windows 2003&quot;) &gt; -1; if (isWin2003) return &quot;Win2003&quot;; var isWinVista = sUserAgent.indexOf(&quot;Windows nt 6.0&quot;) &gt; -1 || sUserAgent.indexOf(&quot;Windows Vista&quot;) &gt; -1; if (isWinVista) return &quot;WinVista&quot;; var isWin7 = sUserAgent.indexOf(&quot;Windows nt 6.1&quot;) &gt; -1 || sUserAgent.indexOf(&quot;Windows 7&quot;) &gt; -1; if (isWin7) return &quot;Win7&quot;; var isWin8 = sUserAgent.indexOf(&quot;windows nt 6.2&quot;) &gt; -1 || sUserAgent.indexOf(&quot;Windows 8&quot;) &gt; -1; if (isWin8) return &quot;Win8&quot;; var isWin10 = sUserAgent.indexOf(&quot;windows nt 10.0&quot;) &gt; -1 || sUserAgent.indexOf(&quot;Windows 10&quot;) &gt; -1; if (isWin10) return &quot;Win10&quot;; &#125; return &quot;其他&quot;; &#125;, getDigits: function () &#123; //判断当前操作系统的版本号 var sUserAgent = navigator.userAgent.toLowerCase(); var is64 = sUserAgent.indexOf(&quot;win64&quot;) &gt; -1 || sUserAgent.indexOf(&quot;wow64&quot;) &gt; -1; if (is64) &#123; return &quot;64位&quot;; &#125; else &#123; return &quot;32位&quot;; &#125; &#125;, getBrowser: function () &#123; // 获取浏览器名 var rMsie = /(msie\\s|trident\\/7)([\\w\\.]+)/; var rTrident = /(trident)\\/([\\w.]+)/; var rEdge = /(chrome)\\/([\\w.]+)/;//IE var rFirefox = /(firefox)\\/([\\w.]+)/; //火狐 var rOpera = /(opera).+version\\/([\\w.]+)/; //旧Opera var rNewOpera = /(opr)\\/(.+)/; //新Opera 基于谷歌 var rChrome = /(chrome)\\/([\\w.]+)/; //谷歌 var rUC = /(chrome)\\/([\\w.]+)/;//UC var rMaxthon = /(chrome)\\/([\\w.]+)/;//遨游 var r2345 = /(chrome)\\/([\\w.]+)/;//2345 var rQQ = /(chrome)\\/([\\w.]+)/;//QQ //var rMetasr = /(metasr)\\/([\\w.]+)/;//搜狗 var rSafari = /version\\/([\\w.]+).*(safari)/; var ua = navigator.userAgent.toLowerCase(); var matchBS, matchBS2; //IE 低版 matchBS = rMsie.exec(ua); if (matchBS != null) &#123; matchBS2 = rTrident.exec(ua); if (matchBS2 != null) &#123; switch (matchBS2[2]) &#123; case &quot;4.0&quot;: return &#123; browser: &quot;Microsoft IE&quot;, version: &quot;IE: 8&quot; //内核版本号 &#125;; break; case &quot;5.0&quot;: return &#123; browser: &quot;Microsoft IE&quot;, version: &quot;IE: 9&quot; &#125;; break; case &quot;6.0&quot;: return &#123; browser: &quot;Microsoft IE&quot;, version: &quot;IE: 10&quot; &#125;; break; case &quot;7.0&quot;: return &#123; browser: &quot;Microsoft IE&quot;, version: &quot;IE: 11&quot; &#125;; break; default: return &#123; browser: &quot;Microsoft IE&quot;, version: &quot;Undefined&quot; &#125;; &#125; &#125; else &#123; return &#123; browser: &quot;Microsoft IE&quot;, version: &quot;IE:&quot; + matchBS[2] || &quot;0&quot; &#125;; &#125; &#125; //IE最新版 matchBS = rEdge.exec(ua); if ((matchBS != null) &amp;&amp; (!(window.attachEvent))) &#123; return &#123; browser: &quot;Microsoft Edge&quot;, version: &quot;Chrome/&quot; + matchBS[2] || &quot;0&quot; &#125;; &#125; //UC浏览器 matchBS = rUC.exec(ua); if ((matchBS != null) &amp;&amp; (!(window.attachEvent))) &#123; return &#123; browser: &quot;UC&quot;, version: &quot;Chrome/&quot; + matchBS[2] || &quot;0&quot; &#125;; &#125; //火狐浏览器 matchBS = rFirefox.exec(ua); if ((matchBS != null) &amp;&amp; (!(window.attachEvent))) &#123; return &#123; browser: &quot;火狐&quot;, version: &quot;Firefox/&quot; + matchBS[2] || &quot;0&quot; &#125;; &#125; //Oper浏览器 matchBS = rOpera.exec(ua); if ((matchBS != null) &amp;&amp; (!(window.attachEvent))) &#123; return &#123; browser: &quot;Opera&quot;, version: &quot;Chrome/&quot; + matchBS[2] || &quot;0&quot; &#125;; &#125; //遨游 matchBS = rMaxthon.exec(ua); if ((matchBS != null) &amp;&amp; (!(window.attachEvent))) &#123; return &#123; browser: &quot;遨游&quot;, version: &quot;Chrome/&quot; + matchBS[2] || &quot;0&quot; &#125;; &#125; //2345浏览器 matchBS = r2345.exec(ua); if ((matchBS != null) &amp;&amp; (!(window.attachEvent))) &#123; return &#123; browser: &quot;2345&quot;, version: &quot;Chrome/ &quot; + matchBS[2] || &quot;0&quot; &#125;; &#125; //QQ浏览器 matchBS = rQQ.exec(ua); if ((matchBS != null) &amp;&amp; (!(window.attachEvent))) &#123; return &#123; browser: &quot;QQ&quot;, version: &quot;Chrome/&quot; + matchBS[2] || &quot;0&quot; &#125;; &#125; //Safari（苹果）浏览器 matchBS = rSafari.exec(ua); if ((matchBS != null) &amp;&amp; (!(window.attachEvent)) &amp;&amp; (!(window.chrome)) &amp;&amp; (!(window.opera))) &#123; return &#123; browser: &quot;Safari&quot;, version: &quot;Safari/&quot; + matchBS[1] || &quot;0&quot; &#125;; &#125; //谷歌浏览器 matchBS = rChrome.exec(ua); if ((matchBS != null) &amp;&amp; (!(window.attachEvent))) &#123; matchBS2 = rNewOpera.exec(ua); if (matchBS2 == null) &#123; return &#123; browser: &quot;谷歌&quot;, version: &quot;Chrome/&quot; + matchBS[2] || &quot;0&quot; &#125;; &#125; else &#123; return &#123; browser: &quot;Opera&quot;, version: &quot;opr/&quot; + matchBS2[2] || &quot;0&quot; &#125;; &#125; &#125; &#125; &#125;; BrowserMatch.init(); console.log(&quot;当前用户IP地址：&quot;); console.log(returnCitySN[&quot;cip&quot;]); console.log(&quot;当前用户所在城市ID：&quot;); console.log(returnCitySN[&quot;cid&quot;]); console.log(&quot;当前用户所在城市：&quot;); console.log(returnCitySN[&quot;cname&quot;]); console.log(&quot;浏览器：&quot;+BrowserMatch.browser + &quot;，内核版本：&quot; + BrowserMatch.version + &quot;，操作系统：&quot; + BrowserMatch.OS); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 5.运行结果 或：","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"nodejs-使用jsonwebtoken对管理后台进行token校验","slug":"前端/2019/120401","date":"2019-12-03T16:00:00.000Z","updated":"2020-09-25T03:04:27.401Z","comments":true,"path":"2019/12/04/前端/2019/120401/","link":"","permalink":"http://yoursite.com/2019/12/04/%E5%89%8D%E7%AB%AF/2019/120401/","excerpt":"","text":"概述对登录管理后台时，进行登录失效校验思路：在管理员登录请求nodejs时，nodejs根据jwt生成token，前端接收token，存放在本地，之后每次请求将token放在header带给nodejs，后端验证token是否失效。 1.引入依赖123const fs = require(&quot;fs&quot;);const path = require(&quot;path&quot;);const jwt = require(&quot;jsonwebtoken&quot;); 2.生成token根据前端登录请求返回data，生成token： 12345678910111213constructor(data) &#123; this.data = data;&#125;generateToken() &#123; let data = this.data; let created = Math.floor(Date.now() / 1000); let cert = fs.readFileSync(path.join(__dirname, &quot;../pem/rsa_private_key.pem&quot;));//私钥 可以自己生成 let token = jwt.sign(&#123; data, exp: created + 60 * 60 * 6, //过期时间6个小时 &#125;, cert, &#123;algorithm: &quot;RS256&quot;&#125;); return token;&#125; 3.返回token到前端123let jwt = new JwtUtil(result[0].userName);let token = jwt.generateToken();ctx.body = &#123; code: 0,data:result[0],access_token: token,&quot;msg&quot;: &quot;登入成功&quot;&#125;; 4.前端接收token数据，并存入本地 5.请求时携带token 6.nodejs校验前端返回token12345678910111213141516// 校验tokenverifyToken() &#123; let token = this.data; let cert = fs.readFileSync(path.join(__dirname, &quot;../pem/rsa_public_key.pem&quot;));//公钥 可以自己生成 let res; try &#123; let result = jwt.verify(token, cert, &#123;algorithms: [&quot;RS256&quot;]&#125;) || &#123;&#125;; let &#123;exp = 0&#125; = result, current = Math.floor(Date.now() / 1000); if (current &lt;= exp) &#123; res = result.data || &#123;&#125;; &#125; &#125; catch (e) &#123; res = &quot;err&quot;; &#125; return res;&#125; 根据结果返回不同状态: 12345678let token = ctx.request.header.myblogtoken;let jwt = new JwtUtil(token);let jwtResult = jwt.verifyToken();if (jwtResult == &quot;err&quot;) &#123; ctx.body = &#123; code: 1001, msg: &quot;登录已过期,请重新登录&quot; &#125;;&#125; else &#123; //处理数据&#125; 7.完整代码①.nodejs新建一个jwt.js的文件： 123456789101112131415161718192021222324252627282930313233343536373839404142// 引入模块依赖const fs = require(&quot;fs&quot;);const path = require(&quot;path&quot;);const jwt = require(&quot;jsonwebtoken&quot;);// 创建 token 类class Jwt &#123; constructor(data) &#123; this.data = data; &#125; //生成token generateToken() &#123; let data = this.data; let created = Math.floor(Date.now() / 1000); //私钥 可以自己生成 let cert = fs.readFileSync(path.join(__dirname, &quot;../pem/rsa_private_key.pem&quot;)); let token = jwt.sign(&#123; data, exp: created + 60 * 60 * 6, //过期时间6个小时 &#125;, cert, &#123;algorithm: &quot;RS256&quot;&#125;); return token; &#125; // 校验token verifyToken() &#123; let token = this.data; //公钥 可以自己生成 let cert = fs.readFileSync(path.join(__dirname, &quot;../pem/rsa_public_key.pem&quot;)); let res; try &#123; let result = jwt.verify(token, cert, &#123;algorithms: [&quot;RS256&quot;]&#125;) || &#123;&#125;; let &#123;exp = 0&#125; = result, current = Math.floor(Date.now() / 1000); if (current &lt;= exp) &#123; res = result.data || &#123;&#125;; &#125; &#125; catch (e) &#123; res = &quot;err&quot;; &#125; return res; &#125;&#125;module.exports = Jwt; ②.引入jwt.js,并根据登录请求返回token： 1const JwtUtil = require(&quot;../common/jwt&quot;); 123456789101112131415161718192021&quot;GET /api/signIn&quot;: async (ctx, next) =&gt; &#123; const db = require(&quot;../db&quot;); const model = require(&quot;./../model&quot;); let parameter = &#123;&#125;; ctx.request.querystring.replace(/([^=&amp;]+)=([^&amp;]*)/g, function(m,key,value) &#123; parameter[decodeURIComponent(key)] = decodeURIComponent(value); &#125;); let result = await db.sequelize.query(&quot;SELECT * FROM mb_system_user WHERE user_name=&quot;111&quot; AND password=&quot;111&quot;&quot; , &#123; type: db.sequelize.QueryTypes.SELECT &#125; ).then(function(results) &#123; return results; &#125;); if(result.length &gt;= 1)&#123; let jwt = new JwtUtil(result[0].userName); let token = jwt.generateToken(); ctx.body = &#123; code: 0,data:result[0],access_token: token,&quot;msg&quot;: &quot;登入成功&quot;&#125;; &#125;else&#123; ctx.body = &#123; code: 500, msg: &quot;用户名或密码输入错误，请重新输入&quot; &#125;; &#125;&#125;, ③.请求时调用校验token是否有效接口： 12345678910&quot;GET /api/jiaoyan&quot;: async (ctx, next) =&gt; &#123; let token = ctx.request.header.myblogtoken; let jwt = new JwtUtil(token); let jwtResult = jwt.verifyToken(); if (jwtResult == &quot;err&quot;) &#123; ctx.body = &#123; code: 1001, msg: &quot;登录已过期,请重新登录&quot; &#125;; &#125; else &#123; ctx.body = &#123; code: 0&#125;; &#125;&#125;, 8.其他代码中运用到的公钥和私钥，可以查看这篇文章： https://www.cnblogs.com/zhangjianqiang/p/10308029.html","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}]},{"title":"永久激活(破解) IntelliJ IDEA 方法","slug":"IT/2019/120202","date":"2019-12-01T16:00:00.000Z","updated":"2020-09-25T03:04:27.390Z","comments":true,"path":"2019/12/02/IT/2019/120202/","link":"","permalink":"http://yoursite.com/2019/12/02/IT/2019/120202/","excerpt":"","text":"概述IntelliJ在业界被公认为最好的java开发工具，尤其在智能代码助手、代码自动提示、重构、J2EE支持、各类版本工具(git、svn等)、JUnit、CVS整合、代码分析、 创新的GUI设计等方面的功能可以说是超常的。 1.下载idea官网：https://www.jetbrains.com/idea/download 2.下载破解jar包百度网盘：https://pan.baidu.com/s/11R8DGLzS1Qbrz0ei-f1UaA 3.将下载好的jar包放入idea的bin目录下如图所示： 4.修改文件修改 bin 目录下的 idea.vmoptions及idea64.exe.vmoptions 文件： 把 idea.vmoptions及idea64.exe.vmoptions 文件加一行如下的配置，记得更换为你保存的文件路径： 1-javaagent:D:\\Program Files (x86)\\JetBrains\\IntelliJ IDEA 2016.2.2\\bin\\JetbrainsCrack-2.5.6.jar 5.修改配置文件在 hosts 文件里面添加如下配置： 10.0.0.0 account.jetbrains.com 6.打开 idea，输入激活码1YZVR7WDLV8-eyJsaWNlbnNlSWQiOiJZWlZSN1dETFY4IiwibGljZW5zZWVOYW1lIjoiamV0YnJhaW5zIGpzIiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMTktMTEtMjYifSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjAxOS0xMS0yNiJ9LHsiY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjAxOS0xMS0yNiJ9LHsiY29kZSI6IlBTIiwicGFpZFVwVG8iOiIyMDE5LTExLTI2In0seyJjb2RlIjoiR08iLCJwYWlkVXBUbyI6IjIwMTktMTEtMjYifSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAxOS0xMS0yNiJ9LHsiY29kZSI6IkNMIiwicGFpZFVwVG8iOiIyMDE5LTExLTI2In0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDE5LTExLTI2In0seyJjb2RlIjoiUkMiLCJwYWlkVXBUbyI6IjIwMTktMTEtMjYifSx7ImNvZGUiOiJSRCIsInBhaWRVcFRvIjoiMjAxOS0xMS0yNiJ9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDE5LTExLTI2In0seyJjb2RlIjoiUk0iLCJwYWlkVXBUbyI6IjIwMTktMTEtMjYifSx7ImNvZGUiOiJXUyIsInBhaWRVcFRvIjoiMjAxOS0xMS0yNiJ9LHsiY29kZSI6IkRCIiwicGFpZFVwVG8iOiIyMDE5LTExLTI2In0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwMTktMTEtMjYifSx7ImNvZGUiOiJSU1UiLCJwYWlkVXBUbyI6IjIwMTktMTEtMjYifV0sImhhc2giOiIxMTA1NzI3NC8wIiwiZ3JhY2VQZXJpb2REYXlzIjowLCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-rsJR5mlJcjibqRu1gQAMUCngMe8i+AOWIi+JZkNFYPET2G1ONcLPcIzoATTRi6ofkDm5l+3Y4HXjBPjVU6bHDdMBAzCnUqpXKsCknwSYyPSU0Y5pzuLvw6O9aPlQ46UBoTEC2BL5W6f11S7NlAq7tTbDuvFUynqSGAmTEfuZtKmzRmp20ejTPuMlSO7UqSkZvkg6YvSTrax1d2K+P9SAmVGZ9iC7AzBs4AwTf84QB9qHvE/Nh0oELSHWGG9hsZZ7sVghI/39/jPQFTp8GLFsl36ZPybPhGDam721zxS9H++/eJk23Jz3nxaRluE4dWmpHrDg1qBHp8qVpSFejg2QYw==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQAF8uc+YJOHHwOFcPzmbjcxNDuGoOUIP+2h1R75Lecswb7ru2LWWSUMtXVKQzChLNPn/72W0k+oI056tgiwuG7M49LXp4zQVlQnFmWU1wwGvVhq5R63Rpjx1zjGUhcXgayu7+9zMUW596Lbomsg8qVve6euqsrFicYkIIuUu4zYPndJwfe0YkS5nY72SHnNdbPhEnN8wcB2Kz+OIG0lih3yz5EqFhld03bGp222ZQCIghCTVL6QBNadGsiN/lWLl4JdR3lJkZzlpFdiHijoVRdWeSWqM4y0t23c92HXKrgppoSV18XMxrWVdoSM3nuMHwxGhFyde05OdDtLpCv+jlWf5REAHHA201pAU6bJSZINyHDUTB+Beo28rRXSwSh3OUIvYwKNVeoBY+KwOJ7WnuTCUq1meE6GkKc4D/cXmgpOyW/1SmBz3XjVIi/zprZ0zf3qH5mkphtg6ksjKgKjmx1cXfZAAX6wcDBNaCL+Ortep1Dh8xDUbqbBVNBL4jbiL3i3xsfNiyJgaZ5sX7i8tmStEpLbPwvHcByuf59qJhV/bZOl8KqJBETCDJcY6O2aqhTUy+9x93ThKs1GKrRPePrWPluud7ttlgtRveit/pcBrnQcXOl1rHq7ByB8CFAxNotRUYL9IF5n3wJOgkPojMy6jetQA5Ogc8Sm7RG6vg1yow== 重新打开idea，就能看到软件失效日期为2099年了，时间够够的了:","categories":[{"name":"IT","slug":"IT","permalink":"http://yoursite.com/categories/IT/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"常用电脑快捷键大全","slug":"IT/2019/120201","date":"2019-12-01T16:00:00.000Z","updated":"2020-09-25T03:04:27.390Z","comments":true,"path":"2019/12/02/IT/2019/120201/","link":"","permalink":"http://yoursite.com/2019/12/02/IT/2019/120201/","excerpt":"","text":"概述电脑快捷键不仅可以帮助我们熟练的操作电脑，还可以帮助我们快速提升自己的工作效率，本文主要介绍wordows、Ctrl、Alt、Shift组合快捷键，熟练运用快捷键可大大提高工作效率。 一.windows快捷键Windows 功能：显示&quot;开始&quot;功能表； Windows+D 功能：显示桌面； Windows+M 功能：缩小桌面所有窗口； Windows+Shift+M 功能：还原桌面所有窗口； Ctrl+Shift+N 功能：新建电脑文件夹； Windows+E 功能：打开我的电脑； Windows+L 功能：锁定电脑 Windows+Ctrl+ F 功能：查找计算机 Windows+F1 功能：显示windows帮助； Windows +Alt +F4 功能：windows关机窗口，或关闭浏览器窗口；二.Ctrl快捷键Ctrl+R 功能：刷新当前页面； Ctrl+Shift 功能：输入法切换； Ctrl+ Spacebar（空格键） 功能：中英文切换； Ctrl+Home 功能：快速移到文件头部； Ctrl+End 功能：快速移到文件尾部； Ctrl+Esc 功能：显示开始菜单栏； Ctrl+F5 功能：强制刷新； Ctrl+Tab+Shift 功能：切换已经打开来的应用； Ctrl+ +（加号） 功能：放大页面； Ctrl+ -（减号） 功能：缩小页面； Ctrl+S 功能：保存； Ctrl+A 功能：全选当前页面内容； Ctrl+C 功能：复制当前选中内容； Ctrl+X 功能：剪切当前选中内容； Ctrl+V 功能：黏贴当前选中内容 ； Ctrl+W 功能：浏览器关闭当前窗口； Ctrl+Y 功能：返回上一步； Ctrl+Z 功能：撤消上一步； Ctrl+Tab 功能：小菜单方式向下切换标签； Ctrl+K 功能：关闭除当前和锁定标签外的所有标签； Ctrl+N 功能：新建空白窗口； Ctrl+P 功能：打开&quot;打印&quot;面板； Ctrl+Q 功能：打开&quot;添加到过滤列表&quot;面板； Ctrl+D 功能：打开&quot;添加收藏&quot;面版； Ctrl+E 功能：打开或关闭&quot;搜索&quot;侧边栏； Ctrl+F 功能：打开&quot;查找&quot;面版； Ctrl+G 功能：打开或关闭&quot;简易收集&quot;面板； Ctrl+H 功能：打开&quot;历史&quot;侧边栏； Ctrl+Alt+Del 功能：打开任务管理器；三.Alt快捷键Alt+F4 功能：关闭当前程序； Alt+Tab 功能：在桌面进行窗口切换； Alt+Z 功能：切换自动换行； Alt+Left 功能：浏览器里前进后退； Alt+F 功能：打开文件菜单搜索； Alt+V 功能：打开视图菜单； Alt+O 功能：打开格式菜单； Alt+A 功能：打开excel表格菜单； Alt+W 功能：打开窗口菜单；四.Shift快捷键Shift+Spacebar（空格键） 功能：切换输入法 半全角； Shift+Ctrl+T 功能：还原上次关闭的标签页； Shift+Del 功能：永久删除文件； Shift+Ctrl+N 功能:新建文件夹; Shift+F10 功能：选中文件的右菜单; Shift + Tab 功能：在选项之间往后移动;五.常用快捷键Ctrl+A 功能：全选当前页面内容； Ctrl+C 功能：复制当前选中内容； Ctrl+X 功能：剪切当前选中内容； Ctrl+V 功能：黏贴当前选中内容 ； Delete 功能：删除当前内容或删除当前文件（删除文件放入回收站）； Shift+Delete 功能：永久删除所选项，不放入回收站； Alt+Tab 功能：在打开的窗口间切换； Alt+Esc 功能：以项目打开的顺序循环切换； Ctrl+Esc 功能：打开“开始”菜单； F5 功能：刷新浏览器当前窗口； Shift+F5 功能：强制刷新当前窗口； Ctrl+Alt+Home或ctrl+home 功能：回到浏览器顶部； Alt+F4 功能：打开关机，重启，待机； Alt+Enter 功能：查看所选项目属性；注：部分快捷键可能受软件影响，如Alt+A可能是微信截图等；","categories":[{"name":"IT","slug":"IT","permalink":"http://yoursite.com/categories/IT/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"微信小程序-计算用户离商家的距离","slug":"前端/2019/120201","date":"2019-12-01T16:00:00.000Z","updated":"2020-09-25T03:04:27.401Z","comments":true,"path":"2019/12/02/前端/2019/120201/","link":"","permalink":"http://yoursite.com/2019/12/02/%E5%89%8D%E7%AB%AF/2019/120201/","excerpt":"","text":"概述前段时间公司在做一个小程序平台的时候，需要用到计算商家与用户之间的距离的功能，然后网上查了下，具体有两种方法，本文主要介绍这两种用法以及其利弊。 问题微信小程序怎么计算用户离商家的距离; 方法1.使用小程序的wx.getLocation 方法获取用户的经纬度,然后用已知的商家的经纬进行计算; 2.利用腾讯地图位置服务calculateDistance直接计算； 实现方法一1.使用小程序提供的获取用户位置信息的api，获取用户信息； 2.获取后台返回的商家经纬度；以深圳北地铁站（22.610564,114.030313）为例； 3.利用公式进行两点的经纬度计算； 代码： 1234567891011121314151617181920212223// 方法调用getDistance:function()&#123; var that = this; wx.getLocation(&#123; type: &quot;wgs84&quot;, success(res) &#123; that.getDistance(res.latitude, res.longitude,22.610564,114.030313); &#125; &#125;)&#125;,// 距离计算distance: function (la1, lo1, la2, lo2) &#123; var La1 = la1 * Math.PI / 180.0; var La2 = la2 * Math.PI / 180.0; var La3 = La1 - La2; var Lb3 = lo1 * Math.PI / 180.0 - lo2 * Math.PI / 180.0; var s = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(La3 / 2), 2) + Math.cos(La1) * Math.cos(La2) * Math.pow(Math.sin(Lb3 / 2), 2))); s = s * 6378.137; s = Math.round(s * 10000) / 10000; s = s.toFixed(2); console.log(&quot;用户距离商家的距离为：&quot; + s); return s;&#125;, 结果： 用户距离商家的距离为：16.42方法二利用腾讯地图位置服务calculateDistance直接计算； 1.前往腾讯位置服务注册登录，并根据步骤申请key： 申请开发者密钥（key）：申请密钥 开通webserviceAPI服务：控制台 -&gt; key管理 -&gt; 设置（使用该功能的key）-&gt; 勾选webserviceAPI -&gt; 保存 (小程序SDK需要用到webserviceAPI的部分服务，所以使用该功能的KEY需要具备相应的权限) 下载微信小程序JavaScriptSDK，微信小程序JavaScriptSDK v1.2 代码： 腾讯api文档：https://lbs.qq.com/qqmap_wx_jssdk/method-calculatedistance.html 1234567891011121314151617181920212223242526272829303132333435363738// 引入SDK核心类var QQMapWX = require(&quot;xxx/qqmap-wx.js&quot;); // 实例化API核心类var qqmapsdk = new QQMapWX(&#123; key: &quot;开发密钥（key）&quot; // 必填&#125;); //在Page(&#123;&#125;)中使用下列代码//事件触发，调用接口formSubmit(e)&#123; var _this = this; //调用距离计算接口 qqmapsdk.calculateDistance(&#123; //mode: &quot;driving&quot;,//可选值：&quot;driving&quot;（驾车）、&quot;walking&quot;（步行），不填默认：&quot;walking&quot;,可不填 //from参数不填默认当前地址 //获取表单提交的经纬度并设置from和to参数（示例为string格式） from: e.detail.value.start || &quot;&quot;, //若起点有数据则采用起点坐标，若为空默认当前地址 to: e.detail.value.dest, //终点坐标 success: function(res) &#123;//成功后的回调 console.log(res); var res = res.result; var dis = []; for (var i = 0; i &lt; res.elements.length; i++) &#123; dis.push(res.elements[i].distance); //将返回数据存入dis数组， &#125; _this.setData(&#123; //设置并更新distance数据 distance: dis &#125;); &#125;, fail: function(error) &#123; console.error(error); &#125;, complete: function(res) &#123; console.log(res); &#125; &#125;);&#125; 优缺点比较方法一： 优点：无需配置，只需两点之间经纬度，无使用次数限制； 缺点：准确度有误差，直接计算的两点之间的距离，比腾讯地图查的距离明显要小； 方法二： 优点：距离精准，与腾讯地图误差较小； 缺点：前期需要配置，且有使用限制，每天只能使用1万次，当然有钱的同学可以去购买配额-https://lbs.qq.com/dev/console/quota/manage； 当然也可以写个判断，限额到了，就使用方法一；","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"设置vscode编辑器为中文环境","slug":"IT/2019/112601","date":"2019-11-25T16:00:00.000Z","updated":"2020-09-25T03:04:27.389Z","comments":true,"path":"2019/11/26/IT/2019/112601/","link":"","permalink":"http://yoursite.com/2019/11/26/IT/2019/112601/","excerpt":"","text":"概述VSCode是一款轻量级的好用的编译软件，运用好vscode可以让你写代码事半功倍，本文章主要介绍怎么将vscode设置为中文开发环境。 正文1.使用快捷键【Ctrl+Shift+P】在弹出的搜索框中输入configure,选择搜索出来的【Configure Display Language】,如下图： 然后选择第二个选项，安装其他语言： 选择中文简体，安装，在重启vscode就行了； 注：版本较低的vscode，可能不是出的 install additional languages这个选项： 而是打开了locale.json文件，可以看到locale的属性值为en，如下图： 这时候我们就需要将en改成zh-CN，然后保存locale.json文件在重启vscode； 重启完之后我们发现编辑器并没有变成中文开发环境，那是应为locale.json中的代码配置的意思是说软件启动加载语言配置包为中文，但是实际上刚刚安装的VSCode并没有中文语言包，所以这里并没有显示为中文语言环境； 因此我们需要在左侧导航栏中选择最后一项Extensions中输入【Chinese （Simplified）Language Pack for Visual Studio Code】，然后点击右侧Install，安装好中文语言包之后软件会提示重启VSCode，点击【Yes】重启VSCode软件，之后就能看到编辑器已经是中文开发环境了：","categories":[{"name":"IT","slug":"IT","permalink":"http://yoursite.com/categories/IT/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"TortoiseGit保存用户名和密码的方法","slug":"IT/2019/112602","date":"2019-11-25T16:00:00.000Z","updated":"2020-09-25T03:04:27.390Z","comments":true,"path":"2019/11/26/IT/2019/112602/","link":"","permalink":"http://yoursite.com/2019/11/26/IT/2019/112602/","excerpt":"","text":"概述tortoiseGit是一个开放的git版本控制系统的源客户端，但是刚安装的TortoiseGit在提交或者pull时总会提示你输入用户名密码，非常麻烦，因此本文主要介绍如何永久保存git的账号密码 正文1.点击鼠标右键进入设置： 2.在设置界面中选择Git–&gt;编辑全局按钮： 3.在末尾添加代码： 123[credential] helper = store 保存，输入一次密码后第二次就会记住密码了 ；","categories":[{"name":"IT","slug":"IT","permalink":"http://yoursite.com/categories/IT/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"nodejs-koa-body实现文件上传","slug":"前端/2019/111901","date":"2019-11-18T16:00:00.000Z","updated":"2020-09-25T03:04:27.401Z","comments":true,"path":"2019/11/19/前端/2019/111901/","link":"","permalink":"http://yoursite.com/2019/11/19/%E5%89%8D%E7%AB%AF/2019/111901/","excerpt":"","text":"概述由于之前写文章上传图片功能没做，都是从简书写完再复制过来，这样导致外链过多，而且太麻烦，所以完善了一下文件上传功能。 一.方法由于我的博客是用nodejs-koa2做的，所以要实现图片上传功能有三种方法： 1：koa-body 2：busboy 3：koa-multer 因为我项目用的是koa-body，所以本文主要讲述的是使用koa-body进行文件上传； 二.实现步骤1.安装koa-body依赖1npm install koa-body --save 或 cnpm install koa-body --save 2.在项目中引入koa-body1234567891011121314151617181920212223242526272829303132333435363738// 判断是单文件还是多文件上传if(ctx.request.files.file.length &gt; 1)&#123; // 多个文件上传 const files = ctx.request.files.file; // 获取上传文件 let dataList = []; //存储返回文件名 for(let i=0;i // 创建可读流 const reader = fs.createReadStream(files[i].path); // 修改文件的名称 var myDate = new Date(); var newFilename = myDate.getTime()+&quot;.&quot;+files[i].name.split(&quot;.&quot;)[1]; var uploadPath = path.join(&quot;/home/img/upload&quot;) + `/$&#123;newFilename&#125;`; // 创建可写流 const upStream = fs.createWriteStream(uploadPath); // 可读流通过管道写入可写流 reader.pipe(upStream); // 存入文件名 dataList.push(&quot;https://www.btluo.com/img/upload/&quot; + newFilename); &#125; // 返回保存文件路径 return ctx.body = &#123; code: 0, data: dataList &#125;;&#125;else&#123; // 单个文件上传 const file = ctx.request.files.file; // 创建可读流 const reader = fs.createReadStream(file.path); // 修改文件的名称 var myDate = new Date(); var newFilename = myDate.getTime()+&quot;.&quot;+file.name.split(&quot;.&quot;)[1]; console.log(newFilename); var uploadPath = path.join(&quot;/home/img/upload&quot;) + `/$&#123;newFilename&#125;`; //创建可写流 const upStream = fs.createWriteStream(uploadPath); // 可读流通过管道写入可写流 reader.pipe(upStream); //返回保存的路径 return ctx.body = &#123; code: 0, data: [&quot;https://www.btluo.com/img/upload/&quot; + newFilename] &#125;;&#125; 注：新版本的koa-body是通过ctx.request.files获取上传的文件，旧版本的koa-body是通过ctx.request.body.files获取上传的文件 ； 附上前端ajax请求代码截图： 1234567891011121314151617$(document).ready(function()&#123; $(&quot;.submitBtn&quot;).on(&quot;click&quot;,() =&gt; &#123; var params = new FormData(); params.append(&quot;name&quot;,$(&quot;.filename&quot;).val()) params.append(&quot;file&quot;,$(&quot;.imgPath&quot;)[0].files[0]) $.ajax(&#123; data: params, url: &quot;http://www.btluo.com/api/uploadFile&quot;, type: &quot;post&quot;, processData: false, contentType: false, success: function(res) &#123; console.log(res) &#125; &#125;) &#125;)&#125;)","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}]},{"title":"如何使用Hexo建站","slug":"前端/2019/111101","date":"2019-11-10T16:00:00.000Z","updated":"2020-09-25T03:04:27.400Z","comments":true,"path":"2019/11/11/前端/2019/111101/","link":"","permalink":"http://yoursite.com/2019/11/11/%E5%89%8D%E7%AB%AF/2019/111101/","excerpt":"","text":"概述Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 用途使用HEXO建自己的博客; 官方网站https://hexo.io/zh-cn/docs/setup 一.什么是HEXOHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 二.安装1.安装前提nodejs(Node.js 版本需不低于 8.6，建议使用 Node.js 10.0 及以上版本)：nodejs安装教程； Git：Git安装教程； 2.全局安装HEXO1npm install -g hexo-cli 三.新建HEXO输入以下命令（myHexoBlog为文件夹名称，可以任意取）： 123hexo init myHexoBlogcd myHexoBlognpm install 新建完成后，指定文件夹的目录如下： ├── _config.yml –网站配置信息。 ├── package.json –应用程序信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 ├── scaffolds –模板文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 ├── source –资源文件夹是存放用户资源的地方。 | ├── _drafts | └── _posts └── themes –主题文件夹 四.去github创建自己的仓库官网：https://github.com 1.创建仓库名称为gitName.github.io, 其中gitName是你的github名称，如下： 2.配置github账户信息（YourName和YourEail都替换成你自己的）： 1get config --global user.name &quot;YourName&quot;： 1get config --global user.email &quot;YourEmail&quot;： 小提示： 查看name：git config user.name；查看email：git config user.email； 3.创建SSH在gitbash中输入：ssh-keygen -t rsa -C “邮箱名”，一路回车。 然后根据C:\\Users\\Administrator.ssh返回路径找到id_rsa.pub文件，也可以继续使用命令：cd ~/.ssh，然后cat id_rsa.pub找到id_rsa.pub文件的内容。 然后复制从ssh-rsa一直到最后。 4.将获取到的ssh放入github中 新建SSH密匙： title随便取，Key填刚刚复制的id_rsa.pub的内容； 5.测试是否成功1ssh -T git@github.com 出现Hi ***! You”ve successfully authenticated, but GitHub does not provide shell access.则表示成功！ 五.修改文件配置打开项目_config.yml文件，修改里面配置（冒号之后都有个半角空格）： 1234567deploy: type:git repo:git@github.com: gitName / gitName .github.io.git branch:master 提示：记得将gitName替换成你自己的github名称; 六.打开本地博客在你的bolg目录下打开gitbash，分别执行以下命令： 123hexo clean -- 清除缓存文件 (db.json) 和已生成的静态文件 (public) hexo generate --生成静态文件hexo server --启动本地服务http://localhost:4000 输入http://localhost:4000，就可以在本地打开博客了： 七.修改主题如果觉得默认主题不是很好看，可以自行下载主题替换：官方网址。 如：https://github.com/yiluyanxia/hexo-theme-antiquity.git： 修改_config.yml中的theme: landscape改为theme: hexo-theme-antiquity，然后重新执行hexo g就行。 建议执行下：hexo clean，清理下public文件内容在执行hexo generate； 最后hexo deploy重新发布就行。效果： 八.上传代码至GitHub1.将写好的文章部署到github服务器上： 1npm install hexo-deployer-git --save 2.执行以下命令： 123hexo clean --清除缓存文件 (db.json) 和已生成的静态文件 (public)hexo generate --生成静态文件hexo deploy --上传代码到gethub Are you sure you want to continue connecting –输yes就行 在浏览器中输入https://gitName.github.io就可以看到你的个人博客啦！ 记得将gitName替换成刚刚设置的仓库名； 九.新建博客在你的bolg目录下运行命令: hexo new 欢迎来到我的博客（名称自取） 然后打开E:\\myHexoBlog\\source_posts文件夹，就可以看到一个欢迎来到我的博客.md的文件。用支持markdown语法的软件打开该文件进行编辑即可。 编辑好以后，运行下述命令： 12hexo cleanhexo d -g 然后，在网址中输入https://gitName.github.io即可看到你的博客上，出现这篇新的文章。 至此，个人博客初步搭建过程就完成了。 我的Hexo博客网址：https://52lb.github.io 仅供参考，内容博文较少。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"微信小程序插件-保存图片到本地","slug":"前端/2019/111102","date":"2019-11-10T16:00:00.000Z","updated":"2020-09-25T03:04:27.401Z","comments":true,"path":"2019/11/11/前端/2019/111102/","link":"","permalink":"http://yoursite.com/2019/11/11/%E5%89%8D%E7%AB%AF/2019/111102/","excerpt":"","text":"概述微信小程序保存图片到本地方法，用户拒绝授权后重新拉取授权方法 分析小程序为保护用户隐私，对保存相册需要进行授权： 一.授权又分三种情况： 1.用户第一次授权； 2.用户拒绝授权； 3.用户已授权； 二.处理逻辑： 1.获取用户授权信息，判断用户是否已授权； 2.判断scope.writePhotosAlbum是否为true， 若为true，则直接保存图片； 若为undefined，则说明是第一次授权，需要调用wx.authorize进行授权，授权框只会在第一次询问时弹出，如果用户已经拒绝了，则不会在弹出，即为false。 若为false，则需要使用wx.openSetting引导用户打开授权设置，用户授权之后才能保存图片到相册； 效果截图 wxml代码1234567891011121314&lt;view class=&quot;couponImg&quot;&gt; &lt;view class=&quot;couponTip&quot;&gt; &lt;view class=&quot;tipBg&quot;&gt;&lt;/view&gt; &lt;view class=&quot;tipContent&quot;&gt; &lt;view class=&quot;iconClose&quot;&gt; &lt;image src=&quot;/images/iconClose.png&quot; bindtap=&quot;closeCoupon&quot;&gt;&lt;/image&gt; &lt;/view&gt; &lt;image src=&quot;&#123;&#123;qrCodeImg&#125;&#125;&quot; class=&quot;qrCode&quot;&gt;&lt;/image&gt; &lt;view class=&quot;saveBtn&quot;&gt; &lt;button class=&quot;btnMain&quot; bindtap=&quot;hasAuthSetting&quot;&gt;保存到相册&lt;/button&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; wxss代码1234567.couponImg .couponTip&#123;width: 100%; position: fixed; top: 0; height: 100vh; z-index: 1001;&#125;.couponImg .tipBg&#123;width: 100vh; height: 100vh; background: rgba(0, 0, 0, 0.4); position: absolute; top: 0; z-index: 1002;&#125;.couponImg .tipContent&#123;width: 80%; height: 1000rpx; position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%);z-index: 1003;&#125;.couponImg .tipContent .qrCode&#123;width: 100%; height: 700rpx;margin-bottom: 20rpx;border-radius: 20rpx;overflow: hidden;&#125;.couponImg .tipContent .iconClose&#123;width: 100%;position: relative;height: 80rpx;&#125;.couponImg .tipContent .iconClose image&#123;width: 64rpx;height: 64rpx;position: absolute;right: -50rpx;&#125;.saveBtn button&#123;width: 80%;margin: 0 auto;border-radius: 50rpx;&#125; js代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162Page(&#123; data: &#123; qrCodeImg: &quot;https://www.btluo.com/images/myXCX01.jpg&quot; &#125;, hasAuthSetting:function() &#123; let that = this; wx.getSetting(&#123; success(res) &#123; if (res.authSetting[&quot;scope.writePhotosAlbum&quot;]) &#123; that.saveImg(); &#125; else if (res.authSetting[&quot;scope.writePhotosAlbum&quot;] === undefined) &#123; wx.authorize(&#123; scope: &quot;scope.writePhotosAlbum&quot;, success() &#123; that.saveImg(); &#125;, fail() &#123; wx.showToast(&#123; title: &quot;您没有授权，无法保存到相册&quot;, icon: &quot;none&quot; &#125;) &#125; &#125;) &#125; else &#123; wx.openSetting(&#123; success(res) &#123; if (res.authSetting[&quot;scope.writePhotosAlbum&quot;]) &#123; that.saveImg(); &#125; else &#123; wx.showToast(&#123; title: &quot;您没有授权，无法保存到相册&quot;, icon: &quot;none&quot; &#125;) &#125; &#125; &#125;) &#125; &#125; &#125;) &#125;, saveImg: function () &#123; let qrCodeImg = this.data.qrCodeImg; wx.downloadFile(&#123; url: qrCodeImg, success: function (res) &#123; var benUrl = res.tempFilePath; //图片保存到本地相册 wx.saveImageToPhotosAlbum(&#123; filePath: benUrl, //授权成功，保存图片 success: function (data) &#123; wx.showToast(&#123; title: &quot;保存成功&quot;, icon: &quot;success&quot;, duration: 2000 &#125;) &#125; &#125;) &#125; &#125;) &#125;,&#125;) 项目案例下载地址：https://gitee.com/caseAddress/wxminiDemo.git –其他小程序插件共用地址，持续更新中","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"在linux中使用nginx时遇到的问题","slug":"后端/2019/101601","date":"2019-10-15T16:00:00.000Z","updated":"2020-09-25T03:04:27.408Z","comments":true,"path":"2019/10/16/后端/2019/101601/","link":"","permalink":"http://yoursite.com/2019/10/16/%E5%90%8E%E7%AB%AF/2019/101601/","excerpt":"","text":"概述在linux中使用nginx重启时，报了一个缺少http_ssl_module模块的错。导致nginx无法重启，本文主要介绍解决方法。 问题在linux中重启nginx时，报了一个错：nginx: [emerg] the “ssl” parameter requires ngx_http_ssl_module in /usr/local/nginx/conf/nginx.conf:53； 原因这是因为当时在linux中安装nginx时没有使用到SSL，所以在之前编译的时候使用的不带SSL的默认编译参数。让nginx重新配置添加SSL模块，就能解决这一问题了。但是，如何在现有nginx的基础上，添加一个支持SSL的编译参数呢？首先要找回原来编译nginx时的编译参数，然后再加上支持SSL的编译参数就行。如果不这样做，那么编译出来的nginx可能就会有问题（某些旧的编译参数被去掉了，使得nginx不能支持某些功能）。 解决方法1.切换到nginx源码包（我的源码所在位置 /home/tool/nginx-1.14.0）： cd /home/tool/nginx-1.14.02.查看ngixn原有的模块（查看下之前默认编译参数）： /usr/local/nginx/sbin/nginx -V 3.重新配置添加SSL模块./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module4.重新编译不需要make install安装。否则会覆盖： make5.备份已安装好的nginxcp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak6.查看当前nginx已启动进程（将刚刚编译好的nginx覆盖掉原来的nginx之前需要将nginx停止）： ps -ef | grep nginx7.停止nginx主进程 kill - QUIT 主进程号 或 kill -TERM 主进程号 8.将刚编译好的nginx覆盖掉原来的nginxcp ./objs/nginx /usr/local/nginx/sbin/这时，会提示是否覆盖，请输入yes，直接回车默认不覆盖 9.重新启动nginxcd （--返回根目录） /usr/local/nginx/sbin/nginx -c/usr/local/nginx/conf/nginx.conf --启动nginx10.查看nginx模块，是否更新/usr/local/nginx/sbin/nginx -V","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"微信小程序插件-多列表显示隐藏","slug":"前端/2019/091902","date":"2019-09-18T16:00:00.000Z","updated":"2020-09-25T03:04:27.400Z","comments":true,"path":"2019/09/19/前端/2019/091902/","link":"","permalink":"http://yoursite.com/2019/09/19/%E5%89%8D%E7%AB%AF/2019/091902/","excerpt":"","text":"概述实现单列表的显示和隐藏，通过wx:if判断就可实现，那么实现多列表的单项显示和隐藏功能应该如何实现呢？下面给大家带来了微信小程序之多列表的显示和隐藏功能。 效果截图 wxml代码12345678910111213141516171819202122232425&lt;!--pages/multiListShowHidden/multiListShowHidden.wxml--&gt;&lt;view class=&quot;container&quot;&gt; &lt;view class=&quot;entryBox bgF5&quot;&gt; &lt;view class=&quot;entryHead cMain f28&quot;&gt;请选择您要入驻的行业：&lt;/view&gt; &lt;view class=&quot;entryBody&quot;&gt; &lt;block wx:for-items=&quot;&#123;&#123;industryInfoData&#125;&#125;&quot;&gt; &lt;view class=&quot;industryDad bgFFF flex ac jcs f32&quot; bindtap=&quot;toggleBtn&quot; id=&quot;&#123;&#123;item.id&#125;&#125;&quot;&gt; &lt;view class=&quot;industryIcon flex ac&quot;&gt; &lt;image src=&quot;&#123;&#123;item.industryIcon&#125;&#125;&quot;&gt;&lt;/image&gt; &lt;view&gt;&#123;&#123;item.industryName&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;view&gt; &lt;image src=&quot;/images/iconBottomArrow.png&quot; class=&quot;bottomArrow&quot; wx:if=&quot;&#123;&#123;uhide==item.id&#125;&#125;&quot;&gt;&lt;/image&gt; &lt;image src=&quot;/images/iconRightArrow.png&quot; class=&quot;rightArrow&quot; wx:else&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;industryChild flex ac f28&quot; wx:if=&quot;&#123;&#123;uhide==item.id&#125;&#125;&quot;&gt; &lt;view class=&quot;childItem tc &#123;&#123;childItem.cid == childActive?&quot;bgMain cfff&quot;:&quot;bgFFF&quot;&#125;&#125;&quot; data-cid=&quot;&#123;&#123;childItem.cid&#125;&#125;&quot; data-cname=&quot;&#123;&#123;childItem.cname&#125;&#125;&quot; bindtap=&quot;toSettledDetail&quot; wx:for=&quot;&#123;&#123;item.industryChild&#125;&#125;&quot; wx:for-item=&quot;childItem&quot; wx:key=&quot;*this&quot;&gt; &#123;&#123;childItem.cname&#125;&#125; &lt;/view&gt; &lt;/view&gt; &lt;/block&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; wxss代码123456.entryBox&#123;width: 100%; min-height: 100vh; overflow: hidden;&#125;.entryHead&#123;width: 90%; padding: 40rpx 5%; box-sizing: border-box;&#125;.industryDad&#123;width: 100%; padding: 40rpx 5%; box-sizing: border-box; border-bottom: 1px solid #f5f5f5;&#125;.industryDad .industryIcon image&#123;width: 50rpx; height: 50rpx; margin-right: 20rpx;&#125;.industryChild&#123;width: 96%; margin: 20rpx 2%;&#125;.industryChild .childItem&#123;width: 28%; margin: 0 2%; padding: 15rpx 10rpx; overflow: hidden;white-space: nowrap;text-overflow: ellipsis;&#125; js代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Page(&#123; data: &#123; uhide: 0, industryInfoData: [] &#125;, //切换隐藏和显示 toggleBtn: function(event) &#123; var that = this; var toggleBtnVal = that.data.uhide; var itemId = event.currentTarget.id; if (toggleBtnVal == itemId) &#123; that.setData(&#123; uhide: 0 &#125;) &#125; else &#123; that.setData(&#123; uhide: itemId &#125;) &#125; &#125;, onLoad: function(options) &#123; var that = this; var data = &#123; &quot;datas&quot;: [ &#123; &quot;id&quot;: 1, &quot;industryIcon&quot;: &quot;/images/mineCollect.png&quot;, &quot;industryName&quot;: &quot;餐饮美食&quot;, &quot;industryChild&quot;: [ &#123; &quot;cid&quot;: 1, &quot;cName&quot;: &quot;小吃快餐&quot; &#125;, &#123; &quot;cid&quot;: 2, &quot;cName&quot;: &quot;面包甜点&quot; &#125;, &#123; &quot;cid&quot;: 3, &quot;cName&quot;: &quot;自助餐&quot; &#125; ] &#125;, &#123; &quot;id&quot;: 2, &quot;industryIcon&quot;: &quot;/images/mineCollect.png&quot;, &quot;industryName&quot;: &quot;家政服务&quot;, &quot;industryChild&quot;: [ &#123; &quot;cid&quot;: 1, &quot;cName&quot;: &quot;扫地&quot; &#125;, &#123; &quot;cid&quot;: 2, &quot;cName&quot;: &quot;洗衣服&quot; &#125;, &#123; &quot;cid&quot;: 3, &quot;cName&quot;: &quot;做饭&quot; &#125; ] &#125;, ] &#125;; that.setData(&#123; industryInfoData: data.datas &#125;) &#125;&#125;) 项目案例下载地址：https://gitee.com/caseAddress/wxminiDemo.git –其他小程序插件共用地址，持续更新中","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"微信小程序插件-多图上传demo","slug":"前端/2019/091901","date":"2019-09-18T16:00:00.000Z","updated":"2020-09-25T03:04:27.400Z","comments":true,"path":"2019/09/19/前端/2019/091901/","link":"","permalink":"http://yoursite.com/2019/09/19/%E5%89%8D%E7%AB%AF/2019/091901/","excerpt":"","text":"概述微信小程序实现多图上传插件 效果截图 wxml代码1234567891011121314&lt;!--pages/uploadImg/uploadImg.wxml--&gt;&lt;view class=&quot;imgsbox&quot;&gt; &lt;view class=&quot;weui-uploader flex ac&quot;&gt; &lt;view class=&quot;imgList&quot; wx:for=&quot;&#123;&#123;imgs&#125;&#125;&quot; wx:for-item=&quot;item&quot; wx:key=&quot;*this&quot;&gt; &lt;image class=&quot;uploadImg&quot; src=&quot;&#123;&#123;item&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot; mode=&quot;aspectFill&quot; bindtap=&quot;previewImg&quot;&gt;&lt;/image&gt; &lt;view class=&quot;delete-btn&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot; catchtap=&quot;deleteImg&quot;&gt; &lt;image class=&quot;imgDelete&quot; src=&quot;/images/iconImgDelete.png&quot;&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;upload-img-btn&quot; bindtap=&quot;chooseImg&quot;&gt; &lt;image src=&quot;/images/iconUploadImg.jpg&quot;&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; wxss代码12345678910111213/* pages/uploadImg/uploadImg.wxss */.imgsbox&#123;width: 690rpx; margin: auto; background: #fff; box-sizing: border-box; overflow: hidden;&#125;.weui-cells&#123;font-size: 30rpx!important;&#125;.weui-cell::before&#123;border-top:1rpx solid #eee;&#125;.upload-img-btn image&#123;width: 140rpx; height: 140rpx; margin: 10rpx;&#125;.imgList&#123;width: 140rpx; height: 140rpx; margin: 15rpx; position: relative; overflow: hidden&#125;.delete-btn&#123;position: absolute; bottom: 0;left: 0; background-color: rgba(0,0,0,.5); color: #fff; text-align: center; line-height: 40rpx; width: 100%;&#125;.imgList .uploadImg&#123;width: 140rpx; height: 140rpx&#125;.weui-select&#123;border-right: none;&#125;.weui-uploader__hd&#123;float: left;&#125;.weui-uploader__title&#123;width: 150rpx!important;&#125;.weui-label&#123;width: 150rpx!important;&#125;.imgDelete&#123;width: 40rpx; height: 40rpx;&#125; js代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105page(&#123; /** * 页面的初始数据 */ data: &#123; imgs: [], imgData: [] &#125;, // 选择图片 chooseImg: function (e) &#123; var that = this; var imgs = that.data.imgs; var count = 3 - imgs.length; //限制只能选择三张，按需求自己改 if (imgs.length &gt;= 3) &#123; this.setData(&#123; lenMore: 1 &#125;); setTimeout(function () &#123; that.setData(&#123; lenMore: 0 &#125;); &#125;, 2500); return false; &#125; wx.chooseImage(&#123; count: count, // 默认9 sizeType: [&quot;compressed&quot;], // 可以指定是原图还是压缩图，默认二者都有 sourceType: [&quot;album&quot;, &quot;camera&quot;], // 可以指定来源是相册还是相机，默认二者都有 success: function (res) &#123; // 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片 var tempFilePaths = res.tempFilePaths; var imgs = that.data.imgs; for (var i = 0; i &lt; tempFilePaths.length; i++) &#123; if (imgs.length &gt;= 9) &#123; that.setData(&#123; imgs: imgs &#125;); // return false; &#125; else &#123; imgs.push(tempFilePaths[i]); &#125; &#125; that.setData(&#123; imgs: imgs &#125;); that.setData(&#123; picture: [] &#125;) var tempFilePaths = that.data.imgs for (var s = 0; s &lt; tempFilePaths.length; s++) &#123; console.log(tempFilePaths[s]); // 上传图片 // wx.uploadFile(&#123; // url: app.config.apiUrl + &quot;Api/Common/uploadImage&quot;, // filePath: tempFilePaths[s], // name: &quot;image&quot;, // success: function (res) &#123; // var data = res.data; // console.log(data) // var data = JSON.parse(res.data); // console.log(data) // var imgData = that.data.imgData; // imgData.push(data.data); // console.log(imgData) // that.setData(&#123; // imgData: imgData // &#125;) // &#125; // &#125;) &#125; &#125;, fail: function (res) &#123; &#125;, complete: function (res) &#123; &#125; &#125;); &#125;, // 删除图片 deleteImg: function (e) &#123; var that = this; var imgs = this.data.imgs; var imgData = that.data.imgData; var index = e.currentTarget.dataset.index; imgs.splice(index, 1); imgData.splice(index, 1); this.setData(&#123; imgs: imgs, imgData: imgData &#125;) &#125;, // 预览图片 previewImg: function (e) &#123; //获取当前图片的下标 var index = e.currentTarget.dataset.index; //所有图片 var imgs = this.data.imgs; wx.previewImage(&#123; //当前显示图片 current: imgs[index], //所有图片 urls: imgs &#125;) &#125;,&#125;) 项目案例下载地址：https://gitee.com/caseAddress/wxminiDemo.git –其他小程序插件共用地址，持续更新中","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"微信小程序插件-分类demo","slug":"前端/2019/091801","date":"2019-09-17T16:00:00.000Z","updated":"2020-09-25T03:04:27.399Z","comments":true,"path":"2019/09/18/前端/2019/091801/","link":"","permalink":"http://yoursite.com/2019/09/18/%E5%89%8D%E7%AB%AF/2019/091801/","excerpt":"","text":"概述一款实用的左右分类联动菜单-（即可左联动，也可右联动），收藏一下 效果截图 wxml代码123456789101112131415161718&lt;view class=&quot;menuLeft&quot;&gt; &lt;scroll-view class=&quot;leftScroll&quot; scroll-x=&quot;true&quot; scroll-y=&quot;true&quot; scroll-with-animation=&quot;true&quot; scroll-top=&quot;&#123;&#123;leftMenuTop&#125;&#125;&quot;&gt; &lt;text class=&quot;menuItem &#123;&#123;index === currentActiveIndex ? &apos;menuActive&apos; : &apos;&apos;&#125;&#125;&quot; wx:for=&quot;&#123;&#123;navList&#125;&#125;&quot; wx:key=&quot;unique&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot; id=&quot;&#123;&#123;index&#125;&#125;&quot; catchtap=&quot;changeMenu&quot;&gt;&#123;&#123;item.c_name&#125;&#125;&lt;/text&gt; &lt;/scroll-view&gt;&lt;/view&gt;&lt;view class=&quot;menuRight&quot;&gt; &lt;scroll-view class=&quot;rightScroll&quot; scroll-y=&quot;true&quot; scroll-with-animation=&quot;true&quot; scroll-top=&quot;&#123;&#123;rightProTop&#125;&#125;&quot; bindscroll=&quot;scroll&quot;&gt; &lt;view class=&quot;pro-item&quot; wx:for=&quot;&#123;&#123;navList&#125;&#125;&quot; wx:key=&quot;unique&quot;&gt; &lt;view class=&quot;classifyName&quot;&gt;&#123;&#123;item.c_name&#125;&#125;&lt;/view&gt; &lt;view class=&quot;classifyListBox flex ac fwrap&quot;&gt; &lt;view class=&quot;classifyList&quot; wx:for-item=&quot;items&quot; wx:for=&quot;&#123;&#123;item.list&#125;&#125;&quot; wx:key=&quot;unique&quot;&gt; &lt;image class=&quot;goodsImg&quot; src=&quot;&#123;&#123;items.url&#125;&#125;&quot;&gt;&lt;/image&gt; &lt;view class=&quot;goodsName&quot;&gt;&#123;&#123;items.goodsName&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/scroll-view&gt;&lt;/view&gt; wxss代码12345678910111213page&#123;background-color: #f0f0f0;&#125;.menuLeft&#123;width: 180rpx;height: 100%;border-right: 1px solid #f5f5f5;position: fixed;background-color: #f5f5f5;top: 0;left: 0;&#125;.leftScroll&#123;width: 100%;height: 100%;&#125;.menuItem&#123;font-size: 26rpx;box-sizing: border-box;height: 100rpx;line-height: 100rpx;width: 180rpx;background-color: #fff;display: block;border-bottom: 1px solid #f5f5f5;position: relative;z-index: 10;text-align: center;&#125;.menuActive&#123;border-left: 10rpx solid #fd6631;background-color: #f0f0f0;&#125;.menuRight&#123;width: 570rpx;box-sizing: border-box;padding-left: 20rpx;padding-right: 20rpx;height: 100%;position: fixed;top: 0;right: 0;&#125;.rightScroll&#123;height: 100%;box-sizing: border-box;&#125;.classifyName&#123;height: 65rpx;line-height: 65rpx;font-size: 28rpx;font-weight: 700;&#125;.classifyListBox&#123;background-color: #fff;overflow: hidden;color: #fff;box-sizing: border-box;padding: 20rpx 0 0 0;&#125;.classifyList&#123;width: 170rpx;overflow: hidden;margin-right: 10rpx;float: left;&#125;.classifyListBox .classifyList:nth-child(3n)&#123;margin-right: 0rpx;&#125;.goodsImg&#123;display: block;width: 100rpx;height: 100rpx;margin: 0 auto;margin-bottom: 15rpx;&#125;.goodsName&#123;width: 100%;overflow: hidden;box-sizing: border-box;height: 42rpx;line-height: 42rpx;text-align: center;font-size: 24rpx;text-overflow: ellipsis;white-space: nowrap;color: #333;margin-bottom: 20rpx;&#125; js代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168// pages/classify/classify.jsvar app = getApp();//声明全局变量let proListToTop = [], menuToTop = [], MENU = 0, windowHeight, timeoutId;// MENU ==&gt; 是否为点击左侧进行滚动的，如果是，则不需要再次设置左侧的激活状态Page(&#123; data: &#123; staticImg: app.globalData.staticImg, currentActiveIndex: 0, // 接口返回的商品数组 navList: [&#123; c_id: &quot;01&quot;, c_name: &quot;餐饮服务&quot;, list: [&#123; id: 1, url: &quot;/images/1.jpg&quot;, goodsName: &quot;分类&quot;, &#125; ] &#125;, &#123; c_id: &quot;07&quot;, c_name: &quot;医院药店&quot;, list: [&#123; id: 1, url: &quot;/images/1.jpg&quot;, goodsName: &quot;分类&quot;, &#125;, &#123; id: 2, url: &quot;/images/1.jpg&quot;, goodsName: &quot;分类&quot;, &#125;, &#123; id: 3, url: &quot;/images/1.jpg&quot;, goodsName: &quot;分类&quot;, &#125;, &#123; id: 4, url: &quot;/images/1.jpg&quot;, goodsName: &quot;分类&quot;, &#125;, &#123; id: 5, url: &quot;/images/1.jpg&quot;, goodsName: &quot;分类&quot;, &#125;, ] &#125;, ], &#125;, onLoad: function (e) &#123; // 确保页面数据已经刷新完毕~ setTimeout(() =&gt; &#123; this.getAllRects() &#125;, 20) &#125;, changeMenu(e) &#123; console.log(proListToTop); // 改变左侧tab栏操作 if (Number(e.target.id) === this.data.currentActiveIndex) return MENU = 1 this.setData(&#123; currentActiveIndex: Number(e.target.id), rightProTop: proListToTop[Number(e.target.id)] &#125;) this.setMenuAnimation(Number(e.target.id)) &#125;, scroll(e) &#123; console.log(e); for (let i = 0; i &lt; proListToTop.length; i++) &#123; if (e.detail.scrollTop &lt; proListToTop[i] &amp;&amp; i !== 0 &amp;&amp; e.detail.scrollTop &gt; proListToTop[i - 1]) &#123; return this.setDis(i) &#125; &#125; // 找不到匹配项，默认显示第一个数据 if (!MENU) &#123; this.setData(&#123; currentActiveIndex: 0 &#125;) &#125; MENU = 0 &#125;, setDis(i) &#123; // 设置左侧menu栏的选中状态 if (i !== this.data.currentActiveIndex + 1 &amp;&amp; !MENU) &#123; this.setData(&#123; currentActiveIndex: i - 1 &#125;) &#125; MENU = 0 this.setMenuAnimation(i) &#125;, setMenuAnimation(i) &#123; // 设置动画，使menu滚动到指定位置。 let self = this console.log(33) if (menuToTop[i].animate) &#123; console.log(11111) // 节流操作 if (timeoutId) &#123; clearTimeout(timeoutId) &#125; timeoutId = setTimeout(() =&gt; &#123; console.log(12138) self.setData(&#123; leftMenuTop: (menuToTop[i].top - windowHeight) &#125;) &#125;, 50) &#125; else &#123; console.log(11) if (this.data.leftMenuTop === 0) return console.log(22) this.setData(&#123; leftMenuTop: 0 &#125;) &#125; &#125;, getActiveReacts() &#123; wx.createSelectorQuery().selectAll(&quot;.menuActive&quot;).boundingClientRect(function (rects) &#123; return rects[0].top &#125;).exec() &#125;, getAllRects() &#123; // 获取商品数组的位置信息 wx.createSelectorQuery().selectAll(&quot;.pro-item&quot;).boundingClientRect(function (rects) &#123; rects.forEach(function (rect) &#123; console.log(rect) // 这里减去44是根据你的滚动区域距离头部的高度，如果没有高度，可以将其删去 // proListToTop.push(rect.top - 44) proListToTop.push(rect.top) &#125;) &#125;).exec() // 获取menu数组的位置信息 wx.createSelectorQuery().selectAll(&quot;.menuItem&quot;).boundingClientRect(function (rects) &#123; wx.getSystemInfo(&#123; success: function (res) &#123; console.log(res); windowHeight = res.windowHeight / 2 // console.log(windowHeight) rects.forEach(function (rect) &#123; menuToTop.push(&#123; top: rect.top, animate: rect.top &gt; windowHeight &#125;) &#125;) &#125; &#125;) &#125;).exec() &#125;, // 获取系统的高度信息 getSystemInfo() &#123; let self = this wx.getSystemInfo(&#123; success: function (res) &#123; windowHeight = res.windowHeight / 2 &#125; &#125;) &#125;&#125;) 项目案例下载地址：https://gitee.com/caseAddress/wxminiDemo.git –其他小程序插件共用地址，持续更新中","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"vue-9.路由：登录状态的判断","slug":"前端/2019/091101","date":"2019-09-10T16:00:00.000Z","updated":"2020-09-25T03:04:27.399Z","comments":true,"path":"2019/09/11/前端/2019/091101/","link":"","permalink":"http://yoursite.com/2019/09/11/%E5%89%8D%E7%AB%AF/2019/091101/","excerpt":"","text":"概述在搭建的系统中，最基本的登录都是必须的，结合Vue的路由，涉及最多的就是登录状态的判断。也就是说，如果一个组件要校验登录状态，则在用户初始进入时，就要去判断用户是否登录。 正文一.在main.js中判断该路由是否需要登录权限： 12345678910111213router.beforeEach((to, from, next) =&gt; &#123; if (to.matched.some(record =&gt; record.meta.requireLogin))&#123; // 判断该路由是否需要登录权限 if (sessionStorage.getItem(&quot;loginInfo&quot;)) &#123; // 判断当前用户的登录信息loginInfo是否存在 next(); &#125; else &#123; next(&#123; path: &quot;/&quot; &#125;) &#125; &#125;else &#123; next(); &#125;&#125;) 二.在登录组件中，做登录成功处理,存储登录信息到loginInfo中： 1sessionStorage.setItem(&quot;loginInfo&quot;,JSON.stringify(res.data.access_token)); 三.在router中的index.js中为路由加入是否登录校验： 1234meta:&#123; // 当前路由需要校验，不需要就不用写 requireLogin:true&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"使用vscode如何建立vue模板","slug":"IT/2019/091101","date":"2019-09-10T16:00:00.000Z","updated":"2020-09-25T03:04:27.389Z","comments":true,"path":"2019/09/11/IT/2019/091101/","link":"","permalink":"http://yoursite.com/2019/09/11/IT/2019/091101/","excerpt":"","text":"概述在vscode中新建.vue的文件时，我希望VSCODE能够根据配置，自动生成我想要的vue的内容。 正文1.打开vscode依次选择文件-&gt;首选项-&gt;用户代码片段，这时候，会出现一个搜索框，然后在搜索框中输入vue，如下所示： 2.进入vue.json选择打开vue.json之后，复制以下内容到这个文件中： 1234567891011121314151617181920212223242526272829303132&#123; &quot;Print to console&quot;: &#123; &quot;prefix&quot;: &quot;vue&quot;, &quot;body&quot;: [ &quot;&lt;!-- $0 --&gt;&quot;, &quot;&lt;template&gt;&quot;, &quot; &lt;div&gt;&lt;/div&gt;&quot;, &quot;&lt;/template&gt;&quot;, &quot;&quot;, &quot;&lt;script&gt;&quot;, &quot;export default &#123;&quot;, &quot; data () &#123;&quot;, &quot; return &#123;&quot;, &quot; &#125;;&quot;, &quot; &#125;,&quot;, &quot;&quot;, &quot; components: &#123;&#125;,&quot;, &quot;&quot;, &quot; computed: &#123;&#125;,&quot;, &quot;&quot;, &quot; mounted: &#123;&#125;,&quot;, &quot;&quot;, &quot; methods: &#123;&#125;&quot;, &quot;&#125;&quot;, &quot;&quot;, &quot;&lt;/script&gt;&quot;, &quot;&lt;style lang=&apos;scss&apos; scoped&gt;&quot;, &quot;&lt;/style&gt;&quot; ], &quot;description&quot;: &quot;Log output to console&quot; &#125;&#125; 保存后关闭这个文件； 3.用法我们新建一个login.vue的文件，然后输入vue，可以看到以下内容： 选择vue，回车后，就能自动生成内容，如下图所示： 4.其他除了vue之外，也可以为.js、.html等各种文件预设代码片段，具体用法可以搜索snippet了解更多；","categories":[{"name":"IT","slug":"IT","permalink":"http://yoursite.com/categories/IT/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"PM2简易使用手册","slug":"后端/2019/091002","date":"2019-09-09T16:00:00.000Z","updated":"2020-09-25T03:04:27.408Z","comments":true,"path":"2019/09/10/后端/2019/091002/","link":"","permalink":"http://yoursite.com/2019/09/10/%E5%90%8E%E7%AB%AF/2019/091002/","excerpt":"","text":"概述PM2是node进程管理工具，可以利用它来简化很多node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等； 一.安装PM2// 全局安装pm2，依赖node和npm npm install -g pm2二.PM2常用命令1.启动命令pm2 start app.js --watch -i 2参数说明： --watch：监听应用目录的变化，一旦发生变化，自动重启。如果要精确监听、不见听的目录，最好通过配置文件。 -i --instances：启用多少个实例，可用于负载均衡。如果-i 0或者-i max，则根据当前机器核数确定实例数目。 --ignore-watch：排除监听的目录/文件，可以是特定的文件名，也可以是正则。比如--ignore-watch=&quot;test node_modules &quot;some scripts&quot;&quot; -n --name：应用的名称。查看应用信息的时候可以用到。 -o --output ：标准输出日志文件的路径。 -e --error ：错误输出日志文件的路径。 --interpreter ：the interpreter pm2 should use for executing app (bash, python...)。比如你用的coffee script来编写应用。2.重启重启特定的应用。可以先通过pm2 list获取应用的名字（–name指定的）或者进程id： pm2 restart app_name|app_id 例：pm2 restart 0 //重启id为0的进程（下同） pm2 restart appName //重启名字为appName的进程（下同） 重启所有应用： pm2 restart all3.停止停止特定的应用。可以先通过pm2 list获取应用的名字（–name指定的）或者进程id： pm2 stop app_name|app_id 停止所有应用： pm2 stop all 4.删除：删除特定的应用。可以先通过pm2 list获取应用的名字（–name指定的）或者进程id： pm2 delete app_name|app_id 关闭并删除所有应用 ： pm2 delete all 5.查看进程状态：pm2 list6.查看某个进程信息：[root@iZ94wb7tioqZ pids]# pm2 describe 0 Describing process with id 0 - name oc-server status online name string id 0 path /data/file/qiquan/over_the_counter/server/bin/www args exec cwd /data/file/qiquan/over_the_counter/server error log path /data/file/qiquan/over_the_counter/server/logs/app-err-0.log out log path /data/file/qiquan/over_the_counter/server/logs/app-out-0.log pid path /root/.pm2/pids/oc-server-0.pid mode fork_mode node v8 arguments watch &amp; reload interpreter node restarts 293 unstable restarts 0 uptime 87m created at 2016-08-26T08:13:43.705Z 7.监控进程监控每个 node 进程的 cpu 和内存使用情况（包括各种响应，错误信息）： pm2 monit 8.显示所有进程的日志信息pm2 logs 9.监控运行这些进程的机器的状态pm2 web 三.配置PM2启动文件pm2 启动的方式可以进行很多的扩展，比如设置环境，设置错误信息打印，设置输入信息打印等等高级功能。那么一条命令就不能完成这些任务，所有 pm2 提供了配置文件的方式来启动～ pm2.config.js： 123456789101112131415161718192021222324252627282930313233// 名称任意，按照个人习惯来module.exports = &#123; apps: [ &#123; name: &quot;&quot;, // 应用名称 script: &quot;./build/server.js&quot;, // 启动文件地址 cwd: &quot;./&quot;, // 当前工作路径 watch: [ // 监控变化的目录，一旦变化，自动重启 &quot;src&quot;, &quot;build&quot;, ], ignore_watch: [ // 忽视这些目录的变化 &quot;node_modules&quot;, &quot;logs&quot;, &quot;public&quot;, ], node_args: &quot;--harmony&quot;, // node的启动模式 env: &#123; //我们可以在内部添加很多个参数变量，这样我们所使用的 process.env.XXX 就会对应发生变化, NODE_ENV: &quot;development&quot;, // 设置运行环境，此时process.env.NODE_ENV的值就是development ORIGIN_ADDR: &quot;&quot; &#125;, env_production: &#123; NODE_ENV: &quot;production&quot;, &#125;, out_file: &quot;./logs/out.log&quot;, // 普通日志路径 error_file: &quot;./logs/err.log&quot;, // 错误日志路径 merge_logs: true, log_date_format: &quot;YYYY-MM-DD HH:mm Z&quot;, &#125;, ],&#125;; 摘抄至PM2实用入门指南，了解更多==》：https://www.cnblogs.com/chyingp/p/pm2-documentation.html","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"如何在 Linux中修改mysql密码","slug":"后端/2019/091001","date":"2019-09-09T16:00:00.000Z","updated":"2020-09-25T03:04:27.407Z","comments":true,"path":"2019/09/10/后端/2019/091001/","link":"","permalink":"http://yoursite.com/2019/09/10/%E5%90%8E%E7%AB%AF/2019/091001/","excerpt":"","text":"概述Linux中修改mysql密码的方法 一.已知原始数据库密码的情况1.登录到mysqlmysql -uroot -p; 2.输入密码，回车3.进入mysql进入之前可以使用show databases;查看当前所有数据库； use mysql; 4.修改密码update user set password=password(&quot;修改后的密码&quot;) where user=&quot;root&quot;; 5.刷新权限：flush privileges; （重要，记得操作）6.退出mysql：exit; 二.忘记root密码的情况1.首先，先停止mysql服务sudo service mysql stop; 2.执行以下语句sudo mysqld_safe --skip-grant-tables &amp; 3.回车下一步步骤2输入完之后，直接按回车后，输入mysql即可登录成功； 4.更新root密码用use mysql关联要操作的数据库，按上面已知密码中步骤4的sql语句直接更新root密码即可： update user set password=password(&quot;修改后的密码&quot;) where user=&quot;root&quot;; 5.刷新权限：flush privileges; （重要，记得操作）6.退出mysql：exit;","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"微信小程序-部分问题集锦","slug":"前端/2019/082201","date":"2019-08-21T16:00:00.000Z","updated":"2020-09-25T03:04:27.399Z","comments":true,"path":"2019/08/22/前端/2019/082201/","link":"","permalink":"http://yoursite.com/2019/08/22/%E5%89%8D%E7%AB%AF/2019/082201/","excerpt":"","text":"概述微信小程序遇到的问题及解决方法集锦，持续更新… 1.去除小程序button点击时出现灰背景答：hover-class=”btn-hover” 给button添加此属性即可去除点击时背景色； 2.动态改变page.json 里面的navigationBarTitleText标题答： wx.setNavigationBarTitle({title: title})； 3.去除小程序button的默认border样式答：.btn:after {border: none;} 4.image标签跟view标签上下会有间隙原因： 图片文字等inline元素默许是跟父级元素的baseline对齐，而baseline又和父级底边有必定间距； 方案一： 将图片转换为块级对象，即img{display:block;}； 方案二： 设置图片的vertical-align属性为“top，text-top，bottom，text-bottom”也可以解决。如： img {vertical-align:top;}； 方案三： 设置图片的浮动属性；即img {float:left;}； 5.小程序input去除空格1.给input绑定bindinput事件； 2.利用数据双向绑定同步当前input的value值； 3.利用正则去除空格（replace(/\\s+/g, ‘’)）； html: 1&lt;input type=&quot;text&quot; bindinput=&quot;getValue&quot; value=&quot;&#123;&#123;value&#125;&#125;&quot; &gt;&lt;/input&gt; js: 123456getValue:function(e)&#123; let val = e.detail.value; this.setData(&#123; value: val.replace(/\\s+/g, &apos;&apos;) &#125;)&#125; 6.在使用canvas绘图时，使用图片做背景遇到的问题背景：在使用图片为背景通过canvsa绘制图片时，会遇到不同手机获取到的背景图片被截取程度会不同，生成的图片并不是我们想要的大小。 因此我们在使用图片作为canvas绘制图片的背景图片时，需要先获取屏幕的分辨率设置图片自适应大小： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 生成海报createPoster: function ()&#123; let that = this , pageBg = this.data.pageBg //背景图片地址 , width; wx.getSystemInfo(&#123; success(res) &#123; width = res.screenWidth; //当前分辨率宽度 &#125; &#125;); //设置自适应大小 const x = width / 750; const ctx = wx.createCanvasContext(&apos;qrCodeCanvas&apos;); console.log(ctx); //主要布局 ctx.clearRect(0, 0, 750, 1204); ctx.fillStyle = &apos;#e04e4e&apos;; ctx.fillRect(0, 0, 750, 1204); //根据分辨率设置背景图片大小；750：图片宽度；1204：图片高度； ctx.drawImage(pageBg, 0, 0, 750 * x, 1204 * x); ctx.draw(false, function () &#123; setTimeout(() =&gt; &#123; // canvas画布转成图片 wx.canvasToTempFilePath(&#123; x: 0, y: 0, width: 750, height: 1204, destWidth: 2250, destHeight: 3612, canvasId: &apos;qrCodeCanvas&apos;, success: function (res) &#123; console.log(res.tempFilePath); that.setData(&#123; qrCodeImgCanvas: res.tempFilePath &#125;) &#125;, fail: function (res) &#123; console.log(&quot;error&quot;); console.log(res); &#125; &#125;) &#125;, 200) &#125;);&#125;,","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"一个实用的jQuery拖放排序插件--DDSort","slug":"前端/2019/080901","date":"2019-08-08T16:00:00.000Z","updated":"2020-09-25T03:04:27.398Z","comments":true,"path":"2019/08/09/前端/2019/080901/","link":"","permalink":"http://yoursite.com/2019/08/09/%E5%89%8D%E7%AB%AF/2019/080901/","excerpt":"","text":"概述网上搜到的一款基于jQuery不错的拖放排序插件 一.拖拽效果 二.html代码12345678910111213141516171819&lt;div id=&quot;wrap&quot;&gt; &lt;ul&gt; &lt;li&gt; 世界上最美好的相遇是恰好，你洽好青春年少，我恰好青春芳华；世界上最唯美的惊艳是偶然，你偶然出现，我偶然发现，然后清纯的两颗心，慢慢地慢慢地靠近； &lt;/li&gt; &lt;li&gt; 你飘逸的裙裾逶迤在我寂寞里飞马行空的诗行，跟随你的优雅舒缓的步履， &lt;/li&gt; &lt;li&gt; 在相濡以沫心心相印的平凡日子里心香如故，刻写一个个浪漫和感动记忆的满面皱纹。 &lt;/li&gt; &lt;li&gt; 除了怀念，只剩怀念；除了无言，只能无言！ &lt;/li&gt; &lt;li&gt; 一些事情，你愈是去遮掩愈是容易清晰，原本以为的瞒天过海，结果却是欲盖弥彰。 &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 三.依次引入jquery.js和ddsort.jsGitHub-demo地址：https://gitee.com/caseAddress/ddsortDraganddrop.git 四.使用DDSort API实现拖放排序效果1234567$( &quot;#wrap&quot;).DDSort(&#123; target: &quot;li&quot;, floatStyle: &#123; &quot;border&quot;: &quot;1px solid #ccc&quot;, &quot;background-color&quot;: &quot;#fff&quot; &#125;&#125;); 五.DDSort API指南 参数列表 类型 描述 target string 插件内部使用的是jQuery的on方法绑定的事件，此参数就是on方法上的选择器字符串 cloneStyle object 可选，设置占位符元素的样式 floatStyle object 可选，设置拖动元素的样式 down function 可选，鼠标按下时执行的函数 move function 可选，鼠标移动时执行的函数 up function 可选，鼠标抬起时执行的函数 六.插件地址下载https://github.com/Barrior/DDSort","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"VSCode-提高工作效率的有效插件","slug":"IT/2019/080801","date":"2019-08-07T16:00:00.000Z","updated":"2020-09-25T03:04:27.389Z","comments":true,"path":"2019/08/08/IT/2019/080801/","link":"","permalink":"http://yoursite.com/2019/08/08/IT/2019/080801/","excerpt":"","text":"概述程序员如何在日常工作中，更快更有效的提高工作效率-看下以下VSCode插件吧 正文vscode提高效率有效使用插件 插件名称 说明 wechat-snippet 这个插件主要的功能就是代码辅助，代码片段自动完成，可以作为上个插件的补充。 minapp 支持微信小程序标签、属性的智能补全，并且提示中包含文档内容（同时支持原生小程序、mpvue 和 wepy 框架，并提供 snippets）。 wxml 这款插件用于将wxml代码进行高亮显示，并且提供代码格式化的功能，可将代码格式化为较易阅读的样式。 vscode weapp api 为 VSCode 提供微信小程序 API 提示及代码片段 。 Auto Close Tag 自动闭合HTML标签 。 Auto Rename Tag 修改HTML标签时，自动修改匹配的标签 。 Color Highlight 颜色值在代码中高亮显示。 Color Picker 拾色器。 ESLint ESLint插件，高亮提示 。 File Peek 根据路径字符串，快速定位到文件 。 vetur 目前比较好的Vue语法高亮 。 HTMLHintHTML 格式提示 。 JavaScript (ES6) code snippets ES6语法代码段 。 markdownlint Markdown格式提示 。 Prettify JSON 格式化JSON。 vscode-Document This jsdoc注释生成。 vscode-eCSStractor 抽取页面的class，生成一个css文档。 vscode-CSS Peek class名字定义跳转。（终于拥有dw cc的这个css定义跳转功能）。 vscode-Live Server http服务器（相当于使用nodejs的http-server ）。 vscode-Change Case 变量名命名风格切换。（解决了命名风格不统一的工具）。 Bookmarks 添加行书签 。 Can I Use HTML5、CSS3、SVG的浏览器兼容性检查。 Code Runner 运行选中代码段（支持大量语言，包括Node）。 CodeBing 在VSCode中弹出浏览器并搜索，可编辑搜索引擎 。 Document This 注释文档生成。 EditorConfig for VS Code EditorConfig插件。 Emoji 在代码中输入emoji 。 Font-awesome codes for html FontAwesome提示代码段 。 ftp-sync 同步文件到ftp。 Git Blame 在状态栏显示当前行的Git信息。 Git History(git log) 查看git log 。 GitLens 显示文件最近的commit和作者，显示当前行commit信息。 Guides 高亮缩进基准线 。 Gulp Snippets Gulp代码段 。 HTML CSS Class Completion CSS class提示。 HTML CSS Support Css提示（支持vue）。 Indenticator 缩进高亮 。 language-stylus Stylus语法高亮和提示。 Lodash Lodash代码段。 MochaSnippets Mocha代码段 。 Node modules resolve 快速导航到Node模块。 npm 运行npm命令 。 npm Intellisense 导入模块时，提示已安装模块名称 。 Output Colorizer 彩色输出信息。 Partial Diff 对比两段代码或文件 。 Path Autocomplete 路径完成提示。 Path Intellisense 另一个路径完成提示。 Project Manager 快速切换项目。 REST Client 发送REST风格的HTTP请求。 Settings Sync VSCode 设置同步到Gist。 String Manipulation 字符串转换处理（驼峰、大写开头、下划线等等） 。 Test Spec Generator 测试用例生成（支持chai、should、jasmine）。 TODO Parser Todo管理 。 Version Lens package.json文件显示模块当前版本和最新版本。 View Node Package 快速打开选中模块的主页和代码仓库。 vscode-icons 文件图标，方便定位文件 。 VSCode Great Icons 文件图标拓展 。 VueHelper Vue2代码段（包括Vue2 api、vue-router2、vuex2）。 Quokka.js 可以即时显示js和ts的运行结果，想试验一些短代码的运行结果，但是又不想之后删除文件的时候可以用到。 codeRunner 可以运行C, C++, Java, JavaScript, PHP, Python, Perl, Perl 6, Ruby, Go, Lua, Groovy, PowerShell, BAT/CMD, BASH/SH, F# Script, F# (.NET Core), C# Script,等开发语言并支持局部执行。 IntelliSense for CSS class names 智能提示 css 的 class 名 Node.js Modules Intellisense 可以在导入语句中自动完成JavaScript / TypeScript模块。 vscode-faker 生成假数据，地址，电话，图片等等。 Regex Previewer 测试正则的插件 open in browser 快速在浏览器中打开html文件（安装后，使用快捷键Alt+B）。","categories":[{"name":"IT","slug":"IT","permalink":"http://yoursite.com/categories/IT/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"vue-基于vue-cli、elementUI的小案例","slug":"前端/2019/080201","date":"2019-08-01T16:00:00.000Z","updated":"2020-09-25T03:04:27.398Z","comments":true,"path":"2019/08/02/前端/2019/080201/","link":"","permalink":"http://yoursite.com/2019/08/02/%E5%89%8D%E7%AB%AF/2019/080201/","excerpt":"","text":"概述基于vue-cli、elementUI的小案例（输入姓名年龄性别，点击创建表格） 一.配置vue参考文章：开发环境配置 二.安装elementui方法①使用命令进行安装： npm i element-ui -S方法②在package.json中添加，后通过cnpm install进行安装： 1.打开package.json，找到devDependencies并在最后加上”element-ui”: “^2.2.1” 123&quot;devDependencies&quot;: &#123; &quot;element-ui&quot;: &quot;^2.2.1&quot;&#125; 2.通过cnpm install安装依赖； 3.找到main.js，引入elementui： 添加一下三行代码： import ElementUI from &quot;element-ui&quot; //新添加 import &quot;element-ui/lib/theme-chalk/index.css&quot; //新添加，避免后期打包样式不同，要放在import App from &quot;./App&quot;;之前 Vue.use(ElementUI) //新添加 添加完之后，就可以开始使用elementui了； 注：elementui组件官网：https://element.faas.ele.me/#/zh-CN/component/installation 三.使用elementui1.新建个demo.vue文件在elementui官网查看组件并使用elementui，在components文件夹中新建一个demo.vue文件： 2.修改HelloWorld.vue的内容 3.添加新路由打开router/index.js，添加新路由；（vue路由文档） 点击进入elementui-demo页面: 至此，我们已经把引入依赖，路由简单配置，简单的elementui组件的使用配置完成了； 4.完善demo组件 首先，从elementui官网中找到我们需要的组件，放进demo.vue中： 其中：凡是以以el-开头的都是element-ui的组件； 运行下代码我们可以看到，添加，删除功能都有了，但是每次刷新页面的时候，数据就会丢失，因此我们可以使用localStorage来临时保存数据； 5.存储数据在src文件夹中新建一个store文件夹，在store文件夹中新建一个store.js，用于存储数据： getItem和setItem是window.localStorage的获取和保存数据的方法 我们用JSON.stringify和JSON.parse把数据转成字符串和解析，这样就方便我们写入tabledata 6.储存好后接着完善demo.vue文件 在script中引入store.js，将tabledata数据换成store中的获取数据的方法，在添加监听事件； 总的来说就是我们点击页面上的创建按钮，watch监听到tabledata有变化，就执行savedata(items){Storage.save(items)}进行数据保存，点击删除时，tabledata也有变化，同样会执行保存； 7.最后之后我们创建的数据，刷新页面也会暂时存储，不会消失的: 四.案例地址https://gitee.com/caseAddress/vueElementuiDemo.git","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"页面css布局神器-flex布局","slug":"前端/2019/080101","date":"2019-07-31T16:00:00.000Z","updated":"2020-09-25T03:04:27.398Z","comments":true,"path":"2019/08/01/前端/2019/080101/","link":"","permalink":"http://yoursite.com/2019/08/01/%E5%89%8D%E7%AB%AF/2019/080101/","excerpt":"","text":"概述摘抄至大神阮一峰的网络日志，为了方便了解更多flex布局知识，将该网站内容收录到我的博客 网页布局（layout）是 CSS 的一个重点应用。 布局的传统解决方案，基于盒状模型，依赖display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。 Flex 布局将成为未来布局的首选方案。本文介绍它的语法： 一.Flex 布局是什么？Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局。 123.box&#123; display: flex;&#125; 行内元素也可以使用 Flex 布局。 123.box&#123; display: inline-flex;&#125; Webkit 内核的浏览器，必须加上-webkit前缀。 1234.box&#123; display: -webkit-flex;/* Safari */ display: flex;&#125; 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。 二.基本概念采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 三.容器的属性以下6个属性设置在容器上: flex-direction flex-wrap flex-flow justify-content align-items align-content3.1 flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）。 123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; 它可能有4个值: row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。3.2 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 它可能取三个值: （1）nowrap（默认）：不换行: （2）wrap：换行，第一行在上方: （3）wrap-reverse：换行，第一行在下方: 3.3 flex-flow属性flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap： 123.box &#123; flex-flow: flex-direction || flex-wrap;&#125; 3.4 justify-content属性123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右： flex-start（默认值）：左对齐； flex-end：右对齐； center： 居中； space-between：两端对齐，项目间的间隔都相等； space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍；3.5 align-items属性align-items属性定义项目在交叉轴上如何对齐。 123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下： flex-start：交叉轴的起点对齐; flex-end：交叉轴的终点对齐; center：交叉轴的中点对齐; baseline: 项目的第一行文字的基线对齐; stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度;3.6 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用： 123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 该属性可能取6个值： flex-start：与交叉轴的起点对齐； flex-end：与交叉轴的终点对齐； center：与交叉轴的中点对齐； space-between：与交叉轴两端对齐，轴线之间的间隔平均分布； space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍； stretch（默认值）：轴线占满整个交叉轴；四.项目的属性以下6个属性设置在项目上: order flex-grow flex-shrink flex-basis flex align-self4.1 order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0: 123.item &#123; order: 1; /* 类型：integer */&#125; 4.2 flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大: 123.item &#123; flex-grow: 0;&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 4.3 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小: 123.item &#123; flex-shrink: 1;&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 4.4 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小: 123.item &#123; flex-basis: 350px | auto;&#125; 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 4.5 flex属性flex属性是flex-grow,flex-shrink和flex-basis的简写，默认值为0 1 auto。后两个属性可选: 123.item &#123; flex: none | [ &lt;&quot;flex-grow&quot;&gt; &lt;&quot;flex-shrink&quot;&gt;? || &lt;&quot;flex-basis&quot;&gt; ]&#125; 该属性有两个快捷值：auto(1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 4.6 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch: 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 注：摘抄至阮一峰的网络日志","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"微信小程序-注册流程及部分注意事项","slug":"前端/2019/070101","date":"2019-06-30T16:00:00.000Z","updated":"2020-09-25T03:04:27.397Z","comments":true,"path":"2019/07/01/前端/2019/070101/","link":"","permalink":"http://yoursite.com/2019/07/01/%E5%89%8D%E7%AB%AF/2019/070101/","excerpt":"","text":"概述微信小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。 一.小程序注册到发布1.注册微信小程序账号https://mp.weixin.qq.com/wxopen/waregister?action=step1&amp;token=&amp;lang=zh_CN 2. 登陆获取微信小程序的AppIDhttps://mp.weixin.qq.com/ 在设置-基本设置中 3. 下载微信开发者工具https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html 4. 创建项目选择项目，填写appid: 5.手机预览调试 两种预览方式： ①. 扫描二维码； ②. 直接编译自动预览； 6. 代码上传 填写版本号，及项目备注； 7.小程序发布代码上传成功后登陆小程序公众平台提交审核发布： 8.注意事项开发前需配置https部署以及设置合法域名，并加入白名单： 二.小程序开发1.微信小程序项目结构及配置Page：存放页面的文件夹 App.js：小程序的脚本代码，所有的页面都可以调用这个js的代码； app.json：小程序的全局配置（可以配置小程序的窗口 背景色，配置导航条样式，配置默认标题等，这个文件不可以添加注释） app.wxss：小程序的公共样式。 其他：每一个小程序页面是由同路径下同名的四个不同后缀文件的组成，如：index.js、index.wxml、index.wxss、index.json。.js 是脚本文件，.json 是配置文件，.wxss 样式文件，.wxml 是页面文件。 index.js我们可以监听并处理页面的生命周期、处理数据，做数据交互等； Index.wxml是页面的结构文件，相当于html，用于数据的展示等； Index.wxss页面样式，相当于css，处理页面布局等； Index.json是页面的配置文件，可以用于修改当前页面的导航栏的颜色标题等，如果不写则默认app.json中的数据； 2. 小程序的生命周期https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html 常用生命周期： 12345678910111213141516171819Page(&#123; data:&#123; &#125;, onLoad:function(options)&#123; // 页面初始化 options为页面跳转所带来的参数 &#125;, onReady:function()&#123; // 页面渲染完成 &#125;, onShow:function()&#123; // 页面显示 &#125;, onHide:function()&#123; // 页面隐藏 &#125;, onUnload:function()&#123; // 页面关闭 &#125;&#125;) 3. 小程序开发api处理①．封装小程序的request请求 使用es6的Promise属性将所有的请求封装好，方便之后请求的调用； ②．新建一个api.js用于存放所有的请求 ③. 调用接口 4.授权登录并获取获取用户信息12345678910App(&#123; onLaunch: function() &#123; wx.login(&#123; success: function(res) &#123; if (res.code) &#123; &#125; else &#123;console.log(“获取用户登录态失败！” + res.errMsg)&#125; &#125; &#125;); &#125;&#125;) ①.通过wx.login()请求得到code，然后通过 https://api.weixin.qq.com/sns/jscode2session?appid=APPID&amp;secret=SECRET&amp;js_code=JSCODE&amp;grant_type=authorization_code去换取session_key和openid; ②.判断用户登录是否过期： 通过wx.checkSessio()请求来判断登录是否过期，失败可以重新调用wx.login()来重新登录; ③.用户授权登录： wx.openSetting()这是以前授权的接口（通过弹框引导用户）； 现在授权是通过button来引导用户授权： 通过wx.getSetting()来判断获取当前用户的授权状态； 通过判断scope这个属性来判断某个功能是否已授权： 授权注意事项： [if !supportLists]1. [endif]注意判断小程序是否是最新版本：wx.canIUse(“button.open-type.getUserInfo”)； ④.获取用户信息 通过wx.login()登录,并通过用户授权之后，就可以通过wx.getUserInfo来获取用户信息了； 5.支付调用官方文档：https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=7_7&amp;index=5 6.小程序转发官方文档：https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/share.html ①.onShareAppMessage():右上角转发配置，及转发后回调函数返回 shareTicket（获取更多转发信息的时候需要通过shareTicket）: 123456789onShareAppMessage: function (res) &#123; if (res.from === “button”) &#123; // 可以通过这个来判断是否是使用按钮分享的 &#125; return&#123; title：分享的标题， Path：“分享的页面路径” &#125;&#125; 页面内发起分享，使用button按钮：open-type=”share”; ②.wx.showSahreMenu()：显示转发按钮； ③.wx.hideSahreMenu():隐藏转发按钮； ④.wx.getShareInfo()；根据 shareTicket 获取已加密的群信息; 三.注意事项1.post请求，json数据格式转换（“content-type”: “application/x-www-form-urlencoded”）； 2.微信小程序有自己的开发单位（rpx，大概1：2比例）； 3.样式文件不支持本地图片，可以使用网络图片，或者base64； 4.一个应用同时只能打开10个页面，当已经打开了10个页面之后，wx.navigateTo不能正常打开新页面。所以不需要的页面可以使用wx.redirectTo进行跳转； 5.小程序项目的文件大小不能超过2M； 6.底部需要导航栏的话，只能配置2-5个tab；跳转到tab页，需使用wx.switchTab，其他跳转方式无法使用； 7.小程序有并发限制，wx.request、wx.uploadFile、wx.downloadFile 的最大并发限制是 10 个。 所有为了保险起见，需要写个请求队列，如果并发量大于10，则需要等待请求。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"jquery on()方法无响应问题","slug":"前端/2019/041201","date":"2019-04-11T16:00:00.000Z","updated":"2020-09-25T03:04:27.397Z","comments":true,"path":"2019/04/12/前端/2019/041201/","link":"","permalink":"http://yoursite.com/2019/04/12/%E5%89%8D%E7%AB%AF/2019/041201/","excerpt":"","text":"概述使用jquery on()方法解决html页面点击元素，事件无响应的问题 正文问题无法触发相应事件的两种代码： 执行以下两种代码时，点击#id时，无alert弹出。 方法一： 123$(&quot;#id&quot;).click( function() &#123; alert(&quot;事件无响应&quot;);&#125;) 方法二： 123$(&quot;#id&quot;).on(&quot;click&quot; , function() &#123; alert(&quot;事件无响应&quot;); &#125;) 原因以上两种方法，只针对页面加载时就存在dom中元素，也就是说&lt;#id&gt;不能是动态添加的元素。 解决方案123$(&quot;body&quot;).on( &quot;click&quot; , &quot;#id&quot; , function() &#123; alert(&quot;事件无响应&quot;); &#125;)","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"vue-8.生命周期钩子函数详解","slug":"前端/2018/122301","date":"2018-12-22T16:00:00.000Z","updated":"2020-09-25T03:04:27.397Z","comments":true,"path":"2018/12/23/前端/2018/122301/","link":"","permalink":"http://yoursite.com/2018/12/23/%E5%89%8D%E7%AB%AF/2018/122301/","excerpt":"","text":"概述每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数。 正文参考链接：生命周期 案例链接：https://gitee.com/caseAddress/vueDemo07.git 一.什么是生命周期钩子函数每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。 比如上一篇文章：vue-事件结合双向绑定实现最简单版todolist中使用到的mounted，也有一些其它的钩子，在实例生命周期的不同阶段被调用，如 beforeDestroy、updated 和 destroyed等。生命周期钩子的 this 上下文指向调用它的 Vue 实例。具体使用api方法：选项-生命周期钩子； vue的8中生命周期函数： 1.beforeCreate：该函数在实例对象刚被创建，还没有绑定属性时触发执行。 2.created：该函数在实例对象完成创建和属性绑定，但是DOM还未生成（$el属性还不存在）时触发执行。 3.beforeMount：该函数在组件挂载之前触发执行。 4.mounted：该函数在组件挂载完成之后触发执行。 5.beforeUpdate：该函数在组件数据更新之前触发执行。 6.updated：该函数在组件数据更新完毕之后触发执行。 7.beforeDestroy：该函数在实例对象销毁之前触发执行。 8.destroyed：该函数在实例对象完成销毁之后触发执行。 钩子函数 触发的行为 在此阶段可以做的事情 beforeCreadted vue实例的挂载元素$el和数据对象data都为undefined，还未初始化。 加loading事件 created vue实例的数据对象data有了，$el还没有 结束loading、请求数据为mounted渲染做准备 beforeMount vue实例的$el和data都初始化了，但还是虚拟的dom节点，具体的data.filter还未替换。 mounted vue实例挂载完成，data.filter成功渲染 配合路由钩子使用 beforeUpdate data更新时触发 updated data更新时触发 数据更新时，做一些处理（此处也可以用watch进行观测） beforeDestroy 组件销毁时触发 destroyed 组件销毁时触发，vue实例解除了事件监听以及和dom的绑定（无响应了），但DOM节点依旧存在 组件销毁时进行提示 二.官网生命周期图","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"vue-7.组件的创建及使用","slug":"前端/2018/122202","date":"2018-12-21T16:00:00.000Z","updated":"2020-09-25T03:04:27.396Z","comments":true,"path":"2018/12/22/前端/2018/122202/","link":"","permalink":"http://yoursite.com/2018/12/22/%E5%89%8D%E7%AB%AF/2018/122202/","excerpt":"","text":"概述vue的组件的功能：把页面抽象成多个相对独立的模块；实现代码重用，提高开发效率和代码质量，使得代码易于维护； 正文案例链接：https://gitee.com/caseAddress/vueDemo06.git 一.什么是组件官方网址-组件详解 1.vue组件的定义 组件可以扩展HTML元素，封装可重用代码 组件也是自定义元素，vue.js的编译器能为他添加特殊功能 部分情况下，组件也可以表现用 is 特性进行了扩展的原生的HTML元素 所有的vue组件同时也都是Vue实例，所以同样有template（html页面），script（js），style（样式），生命周期等； 2.vue组件的功能 能够把页面抽象成多个相对独立的模块； 实现代码重用，提高开发效率和代码质量，使得代码易于维护； 二.创建组件 三.调用组件比如添加一个Home组件： 步骤： 1.在App.vue引入Home组件； 2.挂载组件-名字可以随意取，但是不能重复，也不能跟html标签一样;挂载组件要使用components； 3.在模板中使用组件； 四.案例效果 同理，可以在App.vue挂载更多的组件，也可以在Home组件挂载其他组件； 五.最后上面案例中，我只想给Home中的h2添加背景色不想给App.vue或者其他组件的h2添加样式，那有以下解决方法： 1.给Home组件最外层的div添加一个id，然后在样式的最外层添加id名，比如： 2.在style中添加scoped（表示css的局部作用域）： 这样显示的效果就只有Home组件中的H2添加背景色了：","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"vue-6.事件结合双向绑定实现最简单版todolist","slug":"前端/2018/122201","date":"2018-12-21T16:00:00.000Z","updated":"2020-09-25T03:04:27.396Z","comments":true,"path":"2018/12/22/前端/2018/122201/","link":"","permalink":"http://yoursite.com/2018/12/22/%E5%89%8D%E7%AB%AF/2018/122201/","excerpt":"","text":"概述vue-事件结合双向绑定实现最简单版todolist 正文案例链接https://gitee.com/caseAddress/vueDemo05.git 案例代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;todo&quot; @keyup=&quot;doAdd($event)&quot;&gt; &lt;hr&gt;&lt;br&gt; &lt;h2&gt;进行中&lt;/h2&gt; &lt;ul&gt; &lt;li v-for=&quot;(item,key) in list&quot; v-if=&quot;!item.checkbox&quot;&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;item.checkbox&quot; @change=&quot;saveList()&quot;&gt; &#123;&#123;item.title&#125;&#125; ---- &lt;button @click=&quot;removeData(key)&quot;&gt;删除&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;hr&gt;&lt;br&gt; &lt;h2&gt;已完成&lt;/h2&gt; &lt;ul&gt; &lt;li v-for=&quot;(item,key) in list&quot; v-if=&quot;item.checkbox&quot;&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;item.checkbox&quot; @change=&quot;saveList()&quot;&gt; &#123;&#123;item.title&#125;&#125; ---- &lt;button @click=&quot;removeData(key)&quot;&gt;删除&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;app&apos;, data () &#123; return &#123; todo: &apos;&apos;, list:[] &#125; &#125;, methods:&#123; doAdd(e)&#123; // e.keyCode==13：当敲回车时执行事件 if(e.keyCode==13)&#123; // 增加数据 1.获取文本框的值； 2.把文本框的值push到list上； this.list.push(&#123; title:this.todo, checkbox:false &#125;); this.todo = &apos;&apos;; //把list保存在本地缓存中 localStorage.setItem(&quot;list&quot;,JSON.stringify(this.list)); &#125; &#125;, removeData(key)&#123; // 删除数据 splice:js操作数组的方法 this.list.splice(key,1); //把list保存在本地缓存中 localStorage.setItem(&quot;list&quot;,JSON.stringify(this.list)); &#125;, saveList()&#123; // 保存checkbox的状态 localStorage.setItem(&quot;list&quot;,JSON.stringify(this.list)); &#125; &#125;, mounted()&#123; // vue的生命周期函数--vue页面刷新的时候就会触发的函数 let list = JSON.parse(localStorage.getItem(&quot;list&quot;));//获取本地缓存的list数组 if(list)&#123; this.list = list; &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot;&gt;&lt;/style&gt; 案例效果截图 饭后甜点封装 localStorage.setItem： 案例链接：封装本地缓存（实现todelist功能） 1.新建一个storage.js： 2.在vue.app引入storage.js并调用里面的函数：","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"vue-5.双向数据绑定及ref获取dom节点","slug":"前端/2018/122101","date":"2018-12-20T16:00:00.000Z","updated":"2020-09-25T03:04:27.396Z","comments":true,"path":"2018/12/21/前端/2018/122101/","link":"","permalink":"http://yoursite.com/2018/12/21/%E5%89%8D%E7%AB%AF/2018/122101/","excerpt":"","text":"概述vue双向数据绑定及ref获取dom节点 正文案例链接https://gitee.com/caseAddress/vueDemo04.git 案例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;h2&gt;&#123;&#123;msg&#125;&#125;&lt;/h2&gt; &lt;input type=&quot;text&quot; v-model=&quot;msg&quot;&gt; &lt;!-- 点击事件v-on:click或@click --&gt; &lt;button v-on:click=&quot;getMsg()&quot;&gt;获取表单里面的数据&lt;/button&gt; &lt;button @click=&quot;setMsg()&quot;&gt;设置表单里面的数据&lt;/button&gt; &lt;hr&gt;&lt;br&gt;&lt;br&gt; &lt;!-- ref就是用于获取dom节点的 --&gt; &lt;input type=&quot;text&quot; ref=&quot;userInfo&quot;&gt; &lt;button v-on:click=&quot;getInputVal()&quot;&gt;获取第二个表单里面的数据&lt;/button&gt; &lt;div ref=&quot;box&quot;&gt;我是一个box&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;/* 双向数据绑定 MVVM vue就是一个MVVM框架 M model V view MVVM：model改变会影响视图view，视图view改变会反过来影响model 双向数据绑定必须在表单中使用；*/export default &#123; name: &apos;app&apos;, data () &#123; return &#123; msg: &apos;你好 vue！&apos; &#125; &#125;, methods:&#123; getMsg()&#123; // 获取data方法里面的msg数据：this.msg alert(this.msg); &#125;, setMsg()&#123; this.msg=&quot;我是改变后的数据&quot;; &#125;, getInputVal()&#123; // 获取ref定义的节点 alert(this.$refs.userInfo.value); // 改变box的背景颜色 this.$refs.box.style.background=&quot;red&quot;; &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot;&gt;&lt;/style&gt; 案例效果截图","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"微信小程序-富文本解析出现的问题","slug":"前端/2018/122001","date":"2018-12-19T16:00:00.000Z","updated":"2020-09-25T03:04:27.396Z","comments":true,"path":"2018/12/20/前端/2018/122001/","link":"","permalink":"http://yoursite.com/2018/12/20/%E5%89%8D%E7%AB%AF/2018/122001/","excerpt":"","text":"概述微信小程序wxparse内容页显示不出来不能正确解析html代码 正文问题：微信小程序wxparse内容页显示不出来不能正确解析html代码 解决方法：这个是wxparse代码的一个bug,在一些特殊的手机里面，在wxparse/html2json.js中的第112和119行，都有一个console.dir(这个函数的使用，把这个函数注释掉，内容就可以正常显示出来了。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"vue-4.事件的定义及执行方法","slug":"前端/2018/121901","date":"2018-12-18T16:00:00.000Z","updated":"2020-09-25T03:04:27.395Z","comments":true,"path":"2018/12/19/前端/2018/121901/","link":"","permalink":"http://yoursite.com/2018/12/19/%E5%89%8D%E7%AB%AF/2018/121901/","excerpt":"","text":"概述vue的事件-定义执行方法 正文参考链接vue官网-事件处理 案例链接https://gitee.com/caseAddress/vueDemo03.git 案例代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;h2&gt;&#123;&#123;msg&#125;&#125;&lt;/h2&gt; &lt;button v-on:click=&quot;fun1()&quot;&gt;执行方法的第一种写法&lt;/button&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;button @click=&quot;fun2()&quot;&gt;执行方法的第二种写法&lt;/button&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;button @click=&quot;getMsg()&quot;&gt;获取data里面的msg数据&lt;/button&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;button @click=&quot;setMsg()&quot;&gt;改变data里面的msg数据&lt;/button&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;!-- 用途：用于请求数据等 --&gt; &lt;button @click=&quot;requestData()&quot;&gt;请求数据&lt;/button&gt; &lt;ul&gt; &lt;li v-for=&quot;(item,key) in list&quot;&gt; &#123;&#123;key&#125;&#125;--&#123;&#123;item&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;!-- 方法的传值 --&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;button @click=&quot;passData(&apos;aaa&apos;)&quot;&gt;方法的传值&lt;/button&gt; &lt;!-- 方法的事件对象 --&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;button data-aid=&quot;aaa&quot; @click=&quot;eventFn($event)&quot;&gt;获取事件对象&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;app&apos;, data () &#123; return &#123; msg: &apos;你好 vue！&apos;, list:[] &#125; &#125;, methods:&#123; fun1:function()&#123; alert(&quot;执行方法的第一种写法&quot;); &#125;, // ES6写法可简写，去除:function fun2()&#123; alert(&quot;执行方法的第二种写法&quot;); &#125;, getMsg()&#123; alert(this.msg); &#125;, setMsg()&#123; this.msg=&quot;我是改变后的数据&quot;; &#125;, requestData()&#123; for(var i = 0;i&lt;=10;i++)&#123; this.list.push(&quot;我是第&quot;+ i + &quot;个数据&quot;); &#125; &#125;, passData(val)&#123; alert(val); &#125;, eventFn(e)&#123; console.log(e); // 用途：获取Dom节点 e.srcElement:dom节点 e.srcElement.style.background=&quot;red&quot;; // 或者获取自定义属性的值，尤其是小程序用的非常多 // 获取自定义属性： console.log(e.srcElement.dataset); // 获取自定义属性aid的值： console.log(e.srcElement.dataset.aid); &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot;&gt;&lt;/style&gt; 案例效果截图","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"SEO-搜索网址出现的问题及解决方案","slug":"IT/2018/121801","date":"2018-12-17T16:00:00.000Z","updated":"2020-09-25T03:04:27.388Z","comments":true,"path":"2018/12/18/IT/2018/121801/","link":"","permalink":"http://yoursite.com/2018/12/18/IT/2018/121801/","excerpt":"","text":"概述前段时间，在使用360搜索我的博客网址的时候，360搜索提示“提醒：该页面因服务器不稳定可能无法正常访问!”；百度搜索时没收录网站；然后搜索了一下解决方案； 正文前段时间，在使用360搜索我的博客网址（www.btluo.com）的时候，360搜索提示“提醒：该页面因服务器不稳定可能无法正常访问!” 这个对网站的影响还是蛮大的，尤其是做360搜索引擎的SEO站长，如果处理不及时，网站在360搜索的收录量就会大量下降，甚至对网站的信任度也有一定影响。然后搜索了一下解决方案： 百度说：搜索引擎在抓取网站时，如发现网站经常无法访问，就会在搜索结果中出现此类提示，并给出一下解决方法（https://bbs.360.cn/thread-15235172-1-1.html）： 发现被标记的排查方法，以及标记去除的方法： 1.核实网站是否拦截了360搜索蜘蛛，并导致蜘蛛下载站点失败，建议在服务器中设置访问白名单，将我们的蜘蛛ip加到网站访问允许的白名单中，蜘蛛ip为：http://www.so.com/help/spider_ip.html; 2.如果是https站点，请您先核实站点设置ssl证书是否正确，如存在异常，建议在服务器或联系空间服务商进行调整； 3.网站是否曾有临时关站、访问不稳定、服务器并发次数配额过少的情况，如有，请您对服务器、域名解析等影响访问的关键环节进行检查，确保网站访问可用性; 4.后续请务必注意在访问稳定性上进行提升优化，不要频繁进行变更交割操作，但是如果网站本身已经关闭：请合理设置网站为协议死链。 请务必辛苦检查上述几点是否无问题，否则标记可能无法去除，并且可能导致网站收录等其他问题。 申诉反馈 确认无问题之后，可以通过站长平台，提交不稳定标记申诉反馈，提交的流程如下： 1.通过http://zhanzhang.so.com/，访问360站长平台，并登录帐号： 2.点击右下角“反馈中心”的浮层按钮： 3.在页面（http://zhanzhang.so.com/ExceptionReport/instable）中填写相关的网址信息： 输入网址、问题描述、邮箱提交反馈即可，然后就坐等360 给予答复了； 弄完之后，我又换了个搜索引擎，用百度搜索了一下我的网址，发现也是一样没收录： 好吧，接着百度，百度结果说：理论上是如果你没有在文件里设置禁止百度蜘蛛爬行的话，百度会自动收录的。但这个收录可能会等很久。所以一般情况下，我们都是采用提交自己的网址来达到快速被百度等搜索引擎收录的效果。 解决方案： 打开网页：http://www.baidu.com/search/url_submit.html： 输入自己的网址，提交网站首页; 然后点击站点管理，添加网站： 输入信息，输入域名，下一步，设置好站点领域；（我已经设置好了，可以参考链接：如何让自己的网站快速被百度收录） 一般情况下过半个月或者一两个月就能在百度上搜索到自己的网站了。为何我会说成一般情况下，这也是有原因的，有可能你用的域名在之前被别人用过，别人用的时候被百度K过。这种情况那就比较麻烦了。具体解决方法，自己在网上搜索，我在这里就不多说了。 检测成功： 当你的网站被百度收录了，你可以在百度中这样来查询。输入site:加上你的网址。如图，说明这个网站还没有被百度收录。","categories":[{"name":"IT","slug":"IT","permalink":"http://yoursite.com/categories/IT/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"vue-3.绑定属性，绑定Class 及Style的绑定","slug":"前端/2018/121701","date":"2018-12-16T16:00:00.000Z","updated":"2020-09-25T03:04:27.395Z","comments":true,"path":"2018/12/17/前端/2018/121701/","link":"","permalink":"http://yoursite.com/2018/12/17/%E5%89%8D%E7%AB%AF/2018/121701/","excerpt":"","text":"概述vue的绑定属性，Class 与 Style 绑定 正文参考链接https://cn.vuejs.org/v2/guide/class-and-style.html 案例链接https://gitee.com/caseAddress/vueDemo02.git 1.vue绑定属性： 2.vue绑定class: 3.vue绑定style:","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"VSCode-使用vue的列表渲染提示错误的解决办法","slug":"前端/2018/121601","date":"2018-12-15T16:00:00.000Z","updated":"2020-09-25T03:04:27.394Z","comments":true,"path":"2018/12/16/前端/2018/121601/","link":"","permalink":"http://yoursite.com/2018/12/16/%E5%89%8D%E7%AB%AF/2018/121601/","excerpt":"","text":"概述VSCode使用vue的列表渲染提示错误的解决办法 正文最近在使用vscode使用vue过程中发现使用v-for的方法时，莫名提示错误： 错误示例： 解决方法一： 在v-for后面绑定key，示例如下： 解决方法二： 点击vscode左下角“设置”&gt;“用户设置”，搜索栏输入vetur.validation.template，取消勾选即可： 效果：","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"VSCode-安装vue插件","slug":"前端/2018/121602","date":"2018-12-15T16:00:00.000Z","updated":"2020-09-25T03:04:27.395Z","comments":true,"path":"2018/12/16/前端/2018/121602/","link":"","permalink":"http://yoursite.com/2018/12/16/%E5%89%8D%E7%AB%AF/2018/121602/","excerpt":"","text":"概述学习vue-前期准备 正文开发环境：Win7 x64 开发工具：vsCode 开发工具vsCode插件配置： Vetur、EsLint、Auto Close Tag、JavaScript(ES6) code snippets、Path Intellisense等； Vetur：格式化代码、高亮、代码格式检测、自带Emment、括号自动补全： EsLint ：插件与VUE可能会有冲突，不过你不开启esLint也没多大问题，不过为了你的代码规范 Auto Close Tag : 自动闭合HTML/XML标签 JavaScript(ES6) code snippets : ES6语法智能提示以及快速输入，除js外还支持.ts，.jsx，.tsx，.html，.vue，省去了配置其支持各种包含js代码文件的时间 Path Intellisense： 自动路劲补全","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"vue-2.数据绑定及列表渲染","slug":"前端/2018/121603","date":"2018-12-15T16:00:00.000Z","updated":"2020-09-25T03:04:27.395Z","comments":true,"path":"2018/12/16/前端/2018/121603/","link":"","permalink":"http://yoursite.com/2018/12/16/%E5%89%8D%E7%AB%AF/2018/121603/","excerpt":"","text":"概述数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值 正文项目案例地址https://gitee.com/caseAddress/vueDemo01.git 案例代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!-- 页面html代码，vue模板，所有的内容最外层必须包含一个根节点 --&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 绑定业务逻辑里面的数据 --&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;br&gt; &lt;hr&gt; &lt;!-- 绑定对象数据 --&gt; &lt;div&gt;&#123;&#123;obj.name&#125;&#125;&lt;/div&gt; &lt;br&gt; &lt;hr&gt; &lt;!-- 列表渲染 --&gt; &lt;ul&gt; &lt;li v-for=&quot;item in list&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;br&gt; &lt;hr&gt; &lt;!-- 数组嵌套对象列表循环列表渲染 --&gt; &lt;ul&gt; &lt;li v-for=&quot;item in list1&quot;&gt; &#123;&#123;item.title&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;br&gt; &lt;hr&gt; &lt;!-- 复杂列表循环列表渲染 --&gt; &lt;ul&gt; &lt;li v-for=&quot;item in list2&quot;&gt; &#123;&#123;item.title&#125;&#125; &lt;ul&gt; &lt;li v-for=&quot;IT in item.list&quot;&gt;&#123;&#123;IT.detail&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;!-- 业务逻辑 --&gt;&lt;script&gt;// 将业务逻辑暴露出去export default &#123; data () &#123; //业务逻辑里面定义的数据 return &#123; msg: &quot;你好vue&quot;, obj:&#123; name:&quot;张三&quot; &#125;, list:[&quot;111&quot;,&quot;222&quot;,&quot;333&quot;], list1:[ &#123;title:&quot;11111&quot;&#125;, &#123;title:&quot;22222&quot;&#125;, &#123;title:&quot;33333&quot;&#125; ], list2:[ &#123; &quot;title&quot;:&quot;前端&quot;, list:[ &#123;detail:&quot;前端11111&quot;&#125;, &#123;detail:&quot;前端22222&quot;&#125;, &#123;detail:&quot;前端33333&quot;&#125; ] &#125;, &#123; &quot;title&quot;:&quot;后台&quot;, list:[ &#123;detail:&quot;后台11111&quot;&#125;, &#123;detail:&quot;后台22222&quot;&#125;, &#123;detail:&quot;后台33333&quot;&#125; ] &#125; ] &#125; &#125;&#125;&lt;/script&gt;&lt;!-- 页面样式 --&gt;&lt;style lang=&quot;scss&quot;&gt;&lt;/style&gt; 案例效果截图","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"vue-1.开发环境配置","slug":"前端/2018/121501","date":"2018-12-14T16:00:00.000Z","updated":"2020-09-25T03:04:27.394Z","comments":true,"path":"2018/12/15/前端/2018/121501/","link":"","permalink":"http://yoursite.com/2018/12/15/%E5%89%8D%E7%AB%AF/2018/121501/","excerpt":"","text":"概述vue是一个构建数据驱动的 web 界面的渐进式框架。Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。 正文参考链接：vue官网 安装步骤： 一.必须安装nodejs安装nodejs很简单，直接在官方网站下载http://www.nodejs.org/download/，然后一路next，傻瓜式安装就行了，一般情况下安装好了npm也就自己安装好了，现在官网已经把npm集成在nodejs的安装包里面了，参考链接：nodejs的安装 二.搭建vue的开发环境安装vue的脚手架工具 官方命令行工具 npm install --global vue-cli 或 cnpm install --global vue-cli （此命令只需要执行一次）–cnpm淘宝镜像， 下载包的速度更快一些。 地址：http://npm.taobao.org/ 安装cnpm: npm install -g cnpm --registry=https://registry.npm.taobao.org打开命令行: 输入vue的npm或cnpm的安装命令 ： 三.创建项目cd到对应的一个项目里面，我在D盘建了个vue的文件夹为例； –生产项目vue-demo01 vue init webpack vue-demo01如果安装报错： –进入项目中 cd vue-demo01–如果创建项目的时候没有报错，这一步可以省略。如果报错了 cd到项目里面运行 cnpm install / npm install cnpm install 或 npm install 注： 1.名字是否为vue-dome，可以直接回车或更换；–Project name 2.项目描述，也可以不写，可直接回车；–Project description 3.项目作者，可直接回车；–Author 4.vue build直接回车就行；–Vue build 5.是否安装vue-router，安装就行，后面在了解；–Install vue-router 6.是否安装vue代码检验工具，不建议安装，安装后打个括号可能都会报错；–Use ESLint to lint your code? 7.剩下的都直接回车就行； 项目生成中: 项目生成成功; 项目运行：npm run dev–进入项目 出现这个就打开成功了，浏览器打开就行: vue项目运行成功; 四.另外一种创建项目的方式vue的简单案例，更加简洁，直接安装，推荐使用 vue init webpack-simple vue-demo02 注： 1.名字是否为vue-dome，可以直接回车或更换；–Project name 2.项目描述，也可以不写，可直接回车；–Project description 3.项目作者，可直接回车；–Author 4.是否安装证书，直接回车； 5.是否安装sass，使用就安装，不实用可以不安装； ![我的博客图片](https://upload-images.jianshu.io/upload_images/12858218-ec60071085cde702.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240vue 简单版 –安装成功后，进入项目： cd vue-demo02–安装依赖，简洁版必须安装，否则会报错 cnpm install 或 npm install 安装成功： 简洁版文件相对较少； 运行项目： npm run dev 运行项目: 项目运行成功； 五.目录文件夹说明 名称 说明 build 项目构建的一些代码 config 开发环境的配置 node_modules 依赖包 src 源码，写代码的文件夹 static 静态文件夹 .babelrc ES6编译的一些配置 .editorconfig 代码风格配置文件 .gitignore git上传时忽略的一些文件，比如node_modules .postcssrc.js 转换css样式 index.html 入口文件 package-lock.json 详细项目相信，项目名称，开发依赖记录等 package.json 项目信息，项目名称，开发的依赖的记录等","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"收藏的几个前端实用网站","slug":"IT/2018/111801","date":"2018-11-17T16:00:00.000Z","updated":"2020-09-25T03:04:27.388Z","comments":true,"path":"2018/11/18/IT/2018/111801/","link":"","permalink":"http://yoursite.com/2018/11/18/IT/2018/111801/","excerpt":"","text":"概述收藏了一些实用的网站，持续更新中 正文一、颜色类网站http://color.oulu.me/ 一个集合180种免费的线性渐变网站 ，可在任何网站使用; http://colorhunt.co 这个网站是一个免费开放的色彩灵感平台，拥有数千种时尚的手工挑选调色板; https://webgradients.com/ 180种渐变方案供你选择，可以直接复制CSS样式应用到网页中; https://color.adobe.com/zh/create/color-wheel 这个是Adobe公司出的，他提供了多种配色方案。我们点击圆盘中间的点，就可以调整出我们想要的配色方案; http://www.bootcss.com/p/websafecolors/ 这个网站是为WEB设计，开发中经常用到的安全色。网站内列出了颜色的十六进制码和RGB码，复制粘贴就可以了; http://www.sioe.cn/yingyong/yanse-rgb-16/ 这是一个在线RGB和十六进制颜色码转换工具。在对应的位置填入十六进制代码，点击转换，我们就可以获取到RGB颜色的代码了; 二、图标类网站http://www.iconfont.cn/plus 这是阿里巴巴旗下的图标库网站，直接搜索关键词就可以找到大批的图标。下载图标的时候我们还可以选择颜色、大小、格式，根据自己的需要下载就好了; http://www.easyicon.net/iconsearch/ios/ 这也是一个非常有名的图标库，与上面那个不同的是，这里的图标不是单一颜色的，而是设计好的颜色。下载图标也很简单，直接点击对应图标上面的格式就可以下载; http://www.thinkcmf.com/font/search.html 奥森图标（Font Awesome）提供丰富的矢量字体图标—通过CSS可以任意控制所有图标的大小 ，颜色，阴影; 三、插件类网站http://www.jq22.com/ jQuery插件库; http://www.htmleaf.com/ 这个网站与上一个网站类似，也提供了大量的jQuery插件; http://www.layui.com/ 这是一个强大的模块化前端框架; 四、素材类网站http://588ku.com/ 千库网，一个免费下载图片素材的网站; https://unsplash.com/ Unsplash是一个分享免费高质量照片的网站，照片分辨率都挺大，而且都是真实的摄影师作品，图片多是风景和静物; 五、字体类网站http://www.youziku.com/onlinefont/index 有字库，一个免下载字体，直接在线引用字体的网站; http://www.fonturl.com/ 全球最大的字体网址导航网站; http://www.homefont.cn/ 字体之家，包含17400多种有效字体下载-优秀的免费字体下载站; 六、工具类https://tool.lu/tables md表格生成工具; https://www.chuangkit.com/koutu1/index.html 好用的在线抠图网站; https://www.logaster.cn 免费制作logo的网站; http://tool.lu/ 一个在线工具网站，包含大量在线工具; https://tinypng.com/ 一个在线图片压缩工具，可以批量使用; http://www.css88.com/ 各种前端类工具和技术文章; http://tool.lanrentuku.com/cssformat/ css代码格式化工具; http://www.bejson.com/ 或 http://tool.oschina.net/codeformat/json json在线格式化工具; http://www.wxapp-union.com/ 小程序社区; https://www.91ud.com/ 小程序商店; https://www.uupoop.com/ ps在线; https://codepen.io 前端编码神器; https://www.cnblogs.com/aobing/p/11930859.html 顶级程序员工具集; http://fonts.safe.360.cn 360查字体是否侵权; https://www.meihuama.com （美化码） 或 http://www.9thws.com （第九工场） 或 http://www.mobanma.com/ （模板码） 免费在线美化二维码; 七、学习类https://www.cnblogs.com/ 博客园是一个面向开发者的知识分享社区; https://www.liaoxuefeng.com/ 廖雪峰老师官网，各种教学，可以看看; http://es6.ruanyifeng.com/ es6入门-阮一峰老师; http://www.psjia.com/photoshop/newbie/ PS教程网; https://brushes8.com/category/photoshop-brushes/page/2 PS笔刷下载; https://fly.layui.com/extend/ layui第三方组件平台;","categories":[{"name":"IT","slug":"IT","permalink":"http://yoursite.com/categories/IT/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"React-事件说明","slug":"前端/2018/111501","date":"2018-11-14T16:00:00.000Z","updated":"2020-09-25T03:04:27.394Z","comments":true,"path":"2018/11/15/前端/2018/111501/","link":"","permalink":"http://yoursite.com/2018/11/15/%E5%89%8D%E7%AB%AF/2018/111501/","excerpt":"","text":"概述React框架自身实现了一套事件处理机制，它的基本用法和DOM事件很相似。 正文1.事件的名称要用onClick来代替onclick，onChange来代替onchange等； 2.改变状态值要用this.setState({})来改变； 3.要考虑this的指向，可以使用.bind(this)来强制改变this指向为父级的this指向；","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"React-组件间数据的传递","slug":"前端/2018/111101","date":"2018-11-10T16:00:00.000Z","updated":"2020-09-25T03:04:27.394Z","comments":true,"path":"2018/11/11/前端/2018/111101/","link":"","permalink":"http://yoursite.com/2018/11/11/%E5%89%8D%E7%AB%AF/2018/111101/","excerpt":"","text":"概述在react中，模块组件化了之后，最常使用的就是两个组件之间相互传递数据，其中就包括父组件向子组件传递数据和子组件向父组件传递数据两种情景 正文1.通过父组件传递数据给子组件：通过父组件中给子组件一个属性值: 子组件在通过this.props.属性名来获取父组件传的值: 2.子组件如何改变父组件的值父组件的方法: 把父组件的方法通过属性传递给子组件: 注：在子组件调用父组件的值时需注意this的指向 然后在子组件中调用父组件传递过来的方法 子组件调用父组件方法：","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"React-JSX的使用说明","slug":"前端/2018/110901","date":"2018-11-08T16:00:00.000Z","updated":"2020-09-25T03:04:27.393Z","comments":true,"path":"2018/11/09/前端/2018/110901/","link":"","permalink":"http://yoursite.com/2018/11/09/%E5%89%8D%E7%AB%AF/2018/110901/","excerpt":"","text":"概述JSX 是一个看起来很像 XML 的 JavaScript 语法扩展。 正文1.React 创建一个组件1.return返回的数据不需要加单引号，直接写html标签就行； 2.在JSX的写法中不止能写html标签，还能自定义标签； 3.首字母需要大写；一般标签名是大写开头的就是react中的组件； 4.return返回的内容最外层必须包裹在一个大的元素中，否则会报错；可以使用React的占位符; 5.注释语句：{/**/}； 6.在JSX中写html时，不能在给html直接写class，for这样的属性来增加样式或者用for作为属性，因为会与JSX的语法冲突，所以会使用className，htmlFor来代替它们； 7.如果不想转义html标签，可以使用dangerouslySetInnerHTML来时其不转义，缺点是容易被攻击；","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"React-创建组件","slug":"前端/2018/110601","date":"2018-11-05T16:00:00.000Z","updated":"2020-09-25T03:04:27.393Z","comments":true,"path":"2018/11/06/前端/2018/110601/","link":"","permalink":"http://yoursite.com/2018/11/06/%E5%89%8D%E7%AB%AF/2018/110601/","excerpt":"","text":"概述在react中如何创建一个组件 正文1.React 创建一个组件12345678910111213141516171819import React ,&#123;Component&#125; from &quot;react&quot;;==&gt;import React from &quot;react&quot;;const Component = React Component;//组件名首字母需要大写class TodoList extends Component&#123; constructor(props)&#123; //构造函数，优于其他函数，最先执行 super(props);//固定写法 // 定义数据 this.state=&#123;&#125; &#125; render()&#123; return ( //加个括号使得我们能在多行编写JSX的写法 &lt;div&gt;//JSX语法规定最外层只能放一个标签，return的html标签不需要用双引号包裹，如果不想显示div在dom节点中，则可以用React的&lt;Fragment&gt; 占位符标签代替； 注：import React ,&#123;Component， Fragment &#125; from &quot;react&quot;; &lt;div className=&quot;todoList&quot;&gt;Hello React! &lt;/div&gt;//需要写样式时，增加样式名不能用class，而应该用className； &lt;p&gt;如果我有两个标签，那就要在最外层加一层标签包裹&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;export default TodoList;//记得暴露组件，用于调用 2.调用组件，渲染到页面123456import React from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;import TodoList from &quot;TodoList&quot;;ReactDom.render(,document.getElementById(&quot;todoList&quot;);//将TodoList组件渲染至页面id为todoList的Dom节点中);","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"React-开发环境配置","slug":"前端/2018/110301","date":"2018-11-02T16:00:00.000Z","updated":"2020-09-25T03:04:27.392Z","comments":true,"path":"2018/11/03/前端/2018/110301/","link":"","permalink":"http://yoursite.com/2018/11/03/%E5%89%8D%E7%AB%AF/2018/110301/","excerpt":"","text":"概述React是一个声明式的，高效的，并且灵活的用于构建用户界面的 JavaScript 库，是最近比较流行的语言，所以本文是介绍下React的开发环境的搭建方法的 正文React的开发环境的搭建方法： 1.通过React官网下载最新版，通过引入.js文件来使用React； 2.直接使用 BootCDN 的 React CDN 库,即直接使用线上链接： 1234&lt;script src=&quot;https://cdn.bootcss.com/react/16.4.0/umd/react.development.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/react-dom/16.4.0/umd/react-dom.development.js&quot;&gt;&lt;/script&gt;&lt;!-- 生产环境中不建议使用 --&gt;&lt;script src=&quot;https://cdn.bootcss.com/babel-standalone/6.26.0/babel.min.js&quot;&gt;&lt;/script&gt; 3.通过脚手架工具来编码：（可以使用GRUNT,Gulp,webPack等工具） 在使用react开发项目时，很少有人用传统的方法引入react的源文件(js)，然后在html编辑，一般都是使用webpack + es6来结合react开发前端应用，因此，大部分人会自己搭建脚手架或者使用别人搭建好的脚手架。为了方便React项目的开发，FaceBook 官方发布了一款React的官方脚手架工具。 React脚手架搭建与使用教程： 要使用脚手架工具就需要先安装npm，所以我们首先根据系统选择安装node.js（下载地址：https://nodejs.org/en/download/） 下载后按提示安装，安装完后（windows+R）打开命令cmd： 输入 npm -v 和node -v,如果都出现版本号，即为安装成功; npm安装成功后，就可以近一步的安装Create React App(脚手架工具)了； 首先我们打开React的官方网址，找到Create React App安装命令j教程： 同样通过（windows+R）打开命令行cmd，输入 npm install -g create-react-app安装脚手架工具 安装好之后就能通过create-react-app my-app (my-app是你要创建的项目名) 注：创建项目需在桌面通过（Windows系统：shift+鼠标右键–&gt;在此处打开命令窗口；ios系统：可直接打开命令行输入cd Desktop）打开命令在创建 出现上图所示，就创建成功了，在你的桌面上就能看见一个my-app的文件夹了，然后你就能使用react编写你的项目了。 当然要访问你的react项目，则需要根据上述创建成功后的提示。 通过输入cd my-app 和npm start指令后，它自动为你打开个网址（http://localhost/3000）： 这样就能访问你的项目了：","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"Nginx-虚拟目录alias和root的区别","slug":"IT/2018/110101","date":"2018-10-31T16:00:00.000Z","updated":"2020-09-25T03:04:27.387Z","comments":true,"path":"2018/11/01/IT/2018/110101/","link":"","permalink":"http://yoursite.com/2018/11/01/IT/2018/110101/","excerpt":"","text":"概述Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。 正文nginx中alias标签和root标签到底有哪些区别呢？ 1.alias指定的目录是location匹配访问的path目录下的文件，直接从alias的目录下查找，并且alias指定的目录后面必须要加上”/“符号。； 注：alias虚拟目录配置时，location匹配的目录如果后面不带”/“，那么访问的地址的目录后面加不加”/“不影响访问，访问时它会自动加上”/“；但是如果location匹配的目录后面加上”/“，那么访问的地址的目录必须要加上”/“，访问时它不会自动加上”/“。如果不加”/“，访问就会找不到你想要的资源。 2.root指定的目录是location匹配访问的目录的上一级目录,这个目录一定要是真实存在root指定目录下的；root目录配置中，location匹配的目录后面带不带”/“，都不会影响访问。 例如：（nginx配置的域名是www.baidu.com） &lt;1&gt;. 123location /baidu/ &#123; alias /www/baidu/;&#125; 在上面alias虚拟目录配置下，访问http://www.baidu.com/baidu/ceshi.html 真实路径是/www/baidu/ceshi.html。 上段案例也可用root目录配置： 123location /baidu/ &#123; root /www/;&#125; 两者配置后的访问效果是一样的！ &lt;2&gt;. 上面的案例中alias的虚拟目录名和location匹配访问的目录名是一样的，所以可以直接改成root目录配置，那要是不一样呢？ 例如： 123location /aaa/ &#123; alias /www/baidu/;&#125; 访问http://www.baidu.com/aaa 的时候就会去/www/baidu/ 下查找资源，这样的话，就不能直接改成root目录配置。 如果非要改成root目录配置，就只能在/www下将baidu目录同步为aaa目录，如下： 1234location /aaa/ &#123; root /www/;&#125;# ln -s /www/aaa /www/baidu/ 即保持/www/aaa和/www/baidu 内容一样，这样访问http://www.baidu.com/aaa 的时候也会去/www/baidu/ 下查找资源","categories":[{"name":"IT","slug":"IT","permalink":"http://yoursite.com/categories/IT/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"VSCode前端开发利器","slug":"IT/2018/102801","date":"2018-10-27T16:00:00.000Z","updated":"2020-09-25T03:04:27.387Z","comments":true,"path":"2018/10/28/IT/2018/102801/","link":"","permalink":"http://yoursite.com/2018/10/28/IT/2018/102801/","excerpt":"","text":"概述代码编辑器的选择，可以说是开发者社区中一个经久不衰的话题，现今编辑器的数量数不胜数，vim,Emacs,Atom,sublime Text等等，那么对于一个开发者而言，挑选一个合适的编辑器是可以有效的提高编程效率； 正文一.选择合适的编辑器，提高编程效率代码编辑器的选择，可以说是开发者社区中一个经久不衰的话题，现今编辑器的数量数不胜数，vim，sublime Text,Emacs,Atom等等，那么对于一个开发者而言，挑选一个合适的编辑器是可以有效的提高编程效率； 选择编辑器时，需要考虑的三个因素： 1.选择的编辑器对文本，代码的编程效率要求有多高； 2.选择的编辑器对编程语音的支持如何，配置是否繁琐； 3.选择的编辑器插件生态如何，社区是否活跃； VSCode：是一款免费的、开源的、高性能的、跨平台的、轻量级的代码编辑器，同时，在性能，语言支持、开源社区方面也做的很不错！ 二.学编辑器，到底应该学什么 编辑器的学习就像编程语言的学习类似，一开始不熟悉的一门编程语言的时候，可能会从官方文档，从头到尾的学习这门语言的内容，但是学习过程中一些小小的语法就可能会影响你学习的进度，到之后你完全掌握这门语法的时候，你会发现开始学习时遇到的那点语法问题并不是那么的重要。 在掌握一门编程语言的时候，你想要学习另外一门编程语言，并且还是按照第一次的学习方式去学习这门语言，那么说明你并没有从全局理解这门语言，也没有再脑海中建立“学习框架”。 其实，一门新的编程语言往往是解决老语言的某个短板，但是他们的本质其实并没有多大的改变，如果你在学习第一门语言的时候能建立一套自己的“学习框架”，之后再学习一门新的语言的时候就会更有效率。 同时，学习编辑器的学习，也和编辑语言一样。当使用一个工具时，你最关心的应该是它能用来做什么，它擅长做什么，以及它不能做什么；换句话说，就是指这个工具的‘上限’和‘下限’ 首先，我们先找一下编辑器的‘下限’： 1.快捷键的选用： 首先要考虑编辑器再选用快捷键的时候是否会与系统自带快捷键有所冲突； 其次，要参考其他开发工具对快捷键组合，迎合用户习惯； 最后，也是最重要的一点，我们要看快捷键的配置是否有统一性； 配置的统一性：Shift键只能用于控制文本选择，Ctrl或者Cmd键只能当做辅助键，Tab用于控件之间的跳转等。 2.编程语言以及框架的支持： 选择一个编辑器时，我们需要考虑的是它对你必须使用的编程语言的支持情况如何，语法高亮是否正确，是否能自动补全代码能否直接调试或运行测试等； 3.对工作流的选择和支持 （工作流：是对工作流程及其各操作步骤之间业务规则的抽象、概括描述。） 最后一个影响因素，就是编辑器对工作流的选择和支持，比如说Vim编辑器（http://www.runoob.com/linux/linux-vim.html）并不自带资源管理器，如果你希望在Vim中看到文件树并快速切换文件就需要安装相应的插件；但是现在大多数的编辑器都直接集成了资源管理器，VSCode自带了版本管理，可以说是对版本管理在开发过程中的重要地位的一种认同，但是有些开发工具把测试功能集成进去，这个需求并不是所以人都认为是日常开发必要的； 接着，我们来说说编辑器的‘上限’： 如果说一款编辑器支持用户写插件来定制功能，那么它的‘上限’就很高了。像Eclipse这样允许修改任意功能的工具来说，它们的‘上限’理论就是无限的，但是扩展编辑器这个事，还是需要从社区和个人的，能否达到这个高度还是个未知数。 Eclipse是最流行的java编辑器之一，插件的开发语言也是java，所以它的插件社区还是很活跃的，但是Eclipse把插件运行到主程序中，一旦插件的性能堪忧，就会影响到Eclipse的本身体验。 VSCode的插件开发语言是JavaScript，所以写扩展对于很多人来说是没有门槛的，因为大多数人多少都会写点js，所以对于VSCode来说插件社区的活跃度还是不用担心的，主要是要考虑如何避免跳进Eclipse的坑里。 关于编辑器的‘上限’和‘下限’，其实就是我们再选择编辑器的时候所需要考虑的因素以及学习的方向，当然最重要的就是多动手； 三.关于VSCode VSCode(Visual Studio Code):它是一个免费的，开源的跨平台编辑器。之所以强调‘编辑器’，可能是VSCode并无意成为一个全尺寸的集成开发环境，也就是IDE。它是由Erich Gamma把Monaco Editor移植到桌面平台上，成为了现今的VSCode。 很多人都把编辑器等同于IDE，其实并非如此。IDE更为注重编程体验，对代码有很好的理解，同时侧重于为代码调试、测试等提供图形化界面的支持。因此，可能会显得比较笨重； 而编辑器则相对更轻量，侧重文件或者文件夹，语言，工作流的支持更丰富和自由，VSCode的定位就是编辑器，但又并不局限于此。 开源开发的平台 首先，VSCode的源代码以MIT协议（开源中国）开源，这就意味着我们可以免费获取VSCode的核心代码，社区可以基于VSCode的代码，开发自己的产品；而VSCode也经常能从一些知名的项目中吸取宝贵的经验。 其次，VSCode的源代码托管在GitHub上，同时使用GitHub的开发计划和测试，使每个用户都可以在GitHub上了解VSCode的开发进度，作为用户，可以更好的了解产品的发展情况。 再者，VSCode自带了TypeScript和Node.js的支持，用户下载VSCode后能立即获得javascript和nodejs的智能提示，且无需任何配置即可调试nodejs，然而VSCode的团队并不会精通所有的语言，那么对于他们不熟悉的语言，VSCode该怎么支持呢？最好的方法就是让专业的人来做，所以VSCode为编程工作者提供了统一的API（即Language Server Protocol和 Code Debugging Protocol），使得每一个语言都能得到更好的支持。 VSCode学习指南 1.VSCode有一套自己的快捷键，你可以通过学习快捷键来了解核心编辑器所支持的功能。同时，VSCode允许自定义快捷键，使用户能更好的使用VSCode。VSCode对鼠标，多光标，搜索都有完备的支持，对自动补全，代码片段等都一应俱全。 2.学会使用工作台，工作区，VSCode中除了编辑器区域，还有其他很多功能，像是资源管理器。跨文件搜索、插件管理等，它们就组成了统一的界面，就是工作台；这个工作台的设计代表了VSCode对工作流的选择。VSCode内置的软件版本管理，终端模拟器，调试器等，都能提高工作效率。 3.VSCode允许定制和开发插件，所以试着把自己的想法，来满足自己的需求，能更好的提升自己，了解VSCode； 4.关注每月的发布更新日志，关注VSCode官方博客； 通过以上几个步骤，能更好的使用好VSCode，提高工作效率。 总结：VSCode的定位是轻量级的代码编辑器，综合了Eclipse等许多优秀工具的优势，同时也解决了它们的弊端，VSCode在性能、语言支持、社区方面都很不错； VSCode更新日志：https://code.visualstudio.com/updates/v1_27 VSCode官方博客：https://code.visualstudio.com/blogs/2018/09/12/engineering-with-azure-pipelines VSCode社区：https://code.visualstudio.com/community 四.快速上手VSCode安装与版本选择 VSCode有两个发布渠道，一个是常用的稳定版，每月发布一个主版本；另一个是insiders，每周一到周五早上6点发布，也是VSCode内部团队使用的版本，目的是为了更好的发现Bug。微软内部对这个做法还有个专门的名词：eat your own dog food(吃自己的狗粮)。 VSCode目前在全世界大概有一万五千名用户在使用insiders版本。不过刚接触VSCode，稳定版会相对适合。但是如果已经使用VSCode一段时间的话，可以试一试insiders。因为使用这个版本可以尽早用上最新的功能，一般VSCode的新功能会先在insiders上线，等运行一段时间后才会随着当月稳定版发布。改动较大的可能会运行两个月之后才会推向稳定版。 其次，一个新功能的添加往往是不成熟的，使用insiders可以第一时间在GitHub上反馈对新功能的看法及建议，甚至能为其提供代码。 下载安装VSCode 官网：https://code.visualstudio.com 初次使用VSCode VSCode第一次启动的时候会显示一个‘欢迎使用’页，主要是为了方便快速打开文件，文件夹以及访问历史文件，更换主题色，更换快捷键等： 这个界面有着很多你可能感兴趣的功能： 1.命令面板： 我们可以通过快捷键F1或者Ctrl+Shift+P（mac上的Cmd+Shift+P）键打开VSCode的命令面板。! VSCode的绝大部分命令都能从命令面板找到，所以只要熟悉命令面板，就能不用鼠标，完全使用键盘来完成编码工作。 2.界面概览： 展示VSCode默认界面里的不同部件的位置，名称和快捷键。VSCode强调无鼠标操作，但是记快捷键就会成为很多新手的痛点，这个界面恰好能解决这个痛点。 3.交互式演戏场： 打开这个界面，我们会看到很多的英文教程，它通过各种交互实例，展示了一些高级编辑代码功能的使用，每个功能都会有一个代码片段和编辑器能供我们使用。 五.VSCode快捷键光标移动 1.option + ← ：移动到单词最前面； 2.option + → ：移动到单词最末尾； 3.option + 方向键 ：以单词为单位移动； 4.cmd + ← ：移动到当前行最前面； 5.cmd + → ：移动到当前行最末尾； 6.cmd + shift + \\ ：花括号之间跳转； 7.cmd + 上下键 ：移动到文档第一行或最后一行； 文本选择 基于单词，行，文档的光标操作加上个shift键，就可以移动光标的同时选择文本； 删除操作 删除当前选中文本内容（Windows：home+shift；macOS：cmd+left+shift） 1.cmd + Backspace ：删除当前行光标后的所有字符； 2.cmd + delete ：删除光标前的所有字符； 3.option + delete ：把当前单词光标前的字符删除； 4.option + Backspace ：删除当前单词光标后的字符； 自定义快捷键 打开命令面板（F1或ctrl+shift+p）搜索‘打开键盘快捷方式’，就可以更换或者删除快捷键； 六.VSCode快捷键进阶1.cmd + shfit + k :删除当前代码行； 2.cmd + x ：剪切这行代码； 3.cmd + Enter :在当前行的上面新增一行； 4.option + ‘上下键’：将当前行或者当前选中的几行代码在编辑器中上下移动； 5.option + shift +‘上下方向键’：向上向下复制当前行； 移动代码行，代码缩进发生改变 添加注释 1.cmd + / ：注释一行代码； 2.option + shift + A :注释一整段代码； 格式化代码 1.option + shift + F :格式化代码； 2.cmd + K cmd + F :格式化选中行代码； 3.cmd + shift + P ：代码缩进； 七.文件、符号、代码之间的快速跳转1.Ctrl + Tab(同时按住),继续按着Ctrl键，松开Tab键 :打开当前打开文件的列表，选择要打开文件，松开Ctrl就能打开对应文件； 2.Ctrl + P :打开最近打开文件列表，同时列表顶部出现搜索框，搜索文件名，回车（Enter），可以在当前窗口打开对应文件；使用Cmd + Enter会在新的编辑器窗口打开这个文件。 3.Ctrl + g :行跳转，输入对应数字回车，可以跳转到当前文件的当前行。 4.Ctrl + p(输入文件名 + “：” + 行数)：跳转到指定文件的指定行数。 5.Cmd + shift + O :调出当前文件的符号（函数名等），使用方向键或者搜索，回车，就能跳转到你想要的符号；如果输入“：”可以对当前文件的所有符号进行分类； 6.Ctrl + T ：打开多个文件，搜索多个文件中的符号； 7.F12：跳转到函数的定义处；Cmd + F12 ：跳转到函数的实现位置；注：js中没有接口的概念，定义和实现是相同的，所以js中的F12和Cmd + F12效果是一样的； 8.Shift + F12 ：打开函数引用的预览（把光标放在函数或者类上，按Shift+F12可以打开一个引用列表和内嵌编辑器） 八.VSCode中的鼠标操作1.在VSCode中，单击鼠标左键：把光标移动到相应的位置；双击鼠标左键：将当前光标下的单词选中；三击鼠标左键：选中当前行代码；四次点击鼠标左键：选中整个文档。 2.鼠标左键单击行号：直接选中所在行；按住鼠标左键再行号上下移动：可以选中多行代码； 3.拖动选中的代码，按住鼠标左键，移动鼠标可以改变代码位置；如果想在拖动时复制一份代码，可以按住Ctrl键，操作结果就能从原来的“剪切+复制”变成“复制+黏贴”。 4.VSCode中，如果鼠标拥有中键，只需要按下鼠标中键，然后对着一段文档拖出一个框，再框中的代码就被选中了，而且每一行选中的代码，都有一个独立的光标。 5.悬停提示窗口：当鼠标移动到某些文件上之后，一会就会显示跟鼠标下文本相关的信息；如果鼠标放在某个函数上，按下Ctrl时，则能在悬停提示的窗口上看到该函数的实现。 6.代码的跳转和链接：如果我们把鼠标放在函数上时，函数下方会出现一个下划线，然后当我们按下鼠标左键时，就能跳转到该函数的定义处。 当我们再编写Markdown这样的非编程语言的文档时，通过Ctrl+鼠标左键能打开超级链接。","categories":[{"name":"IT","slug":"IT","permalink":"http://yoursite.com/categories/IT/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"nodejs-登录注册小结","slug":"前端/2018/102501","date":"2018-10-24T16:00:00.000Z","updated":"2020-09-25T03:04:27.392Z","comments":true,"path":"2018/10/25/前端/2018/102501/","link":"","permalink":"http://yoursite.com/2018/10/25/%E5%89%8D%E7%AB%AF/2018/102501/","excerpt":"","text":"概述在搭建博客之前，我就试着去学习nodejs，想用nodejs做后台，看着廖雪峰老师的官网，自己做了个nodejs的登录注册，现在做个小结。 正文项目链接 nodejs登录 目录结构1.Kao对目录views传入的http请求进行url的处理； 123456789async (ctx, next) =&gt; &#123; await next(); //处理下一个异步函数 ctx.response.type = &quot;text/html &quot; ;// 设置response的Content-Type； ctx.response.body = &quot; 登录注册 &quot; ; // 设置response的内容；&#125; 通过参数ctx可以访问http请求的request和response，来进行页面的跳转处理或者编写相应的业务逻辑； 使用方法，在项目描述文件package.json中的dependencies写好依赖包{ “dependencies”:{ “koa”:”2.0.0”}}，然后执行npm install，npm会把我们所需要的包下载好； 为什么要调用await next()？ 因为koa把很多async函数组成一个处理链，每个async函数都可以做一些自己的事情，然后用await next()来调用下一个async函数。我们把每个async函数称为middleware，这些middleware可以组合起来，完成很多有用的功能。 2.koa-router为了集中处理url，我们需要引入koa-router这个middleware，让它负责处理URL映射； 图片来源：廖老师官网 然后，我们可以使用router.get(“/path”, async fn)来注册一个GET请求，可以在请求路径中使用带变量的/hello/:name，变量可以通过ctx.params.name访问。 处理post请求： 用router.get(“/path”, async fn)处理的是get请求。如果要处理post请求，可以用router.post(“/path”, async fn)）； 用post请求处理URL时，我们会遇到一个问题：post请求通常会发送一个表单，或者JSON，它作为request的body发送，但无论是Node.js提供的原始request对象，还是koa提供的request对象，都不提供解析request的body的功能！因此，我们需要koa-bodyparser来解析原始request请求然后绑定在ctx.request.body中。 3.koa-router解析post请求的request的参数； 使用controller进行重构 所有处理URL的函数按功能组存放在controllers目录，今后我们也只需要不断往这个目录下加东西就可以了。 4.Nunjucks(数据模板引擎)通过Nunjucks把数据渲染成html； MVC 5.访问MySQL数据库ORM（Object-Relational Mapping）：关系数据库的表结构映射到对象上; 1.创建一个sequelize对象实例； 2.定义模型，告诉Sequelize如何映射数据库表； 3.根据需要查询数据； Sequelize的API可以参考 http://docs.sequelizejs.com/。 6.运行nodejsnpm start;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}]},{"title":"nodejs-koa2整合sequelize","slug":"前端/2018/102001","date":"2018-10-19T16:00:00.000Z","updated":"2020-09-25T03:04:27.392Z","comments":true,"path":"2018/10/20/前端/2018/102001/","link":"","permalink":"http://yoursite.com/2018/10/20/%E5%89%8D%E7%AB%AF/2018/102001/","excerpt":"","text":"概述使用koa的sequelize查询数据的时候，用await的写法不能满足我的需求，我只要查询部分数据，并将数据库的表的列名从下划线改为驼峰，所以百度到sequelize的官网可以使用原始的sql语句。 正文问题 使用koa的sequelize查询数据的时候，用await的写法： 1234567(async () =&gt; &#123; var pets = await Pet.findAll(&#123;where: &#123;name: &quot;btluo&quot; &#125; &#125;); console.log(`find $&#123;pets.length&#125; pets:`); for (let p of pets) &#123; console.log(JSON.stringify(p)); &#125;&#125;)(); 不能满足我的需求，我只要查询部分数据，并将数据库的表的列名从下划线改为驼峰，所以百度到sequelize的官网可以使用原始的sql语句。 https://itbilu.com/nodejs/npm/VkYIaRPz-.html#induction 解决方案使用sequelize.query() - 执行查询： 123456sequelize.query(&quot;SELECT...&quot;).spread(function (results, metadata) &#123; // Raw query - use spread&#125;);sequelize.query(&quot;SELECT...&quot;, &#123; type: sequelize.QueryTypes.SELECT &#125;).then(function (results) &#123; // SELECT query - use then&#125;) 来满足我的要求，但是我使用sequelize.query的时候 总是报错sequelize.query() is not a function,然后我发现找了好久，把sequelize重新装，更新到最新版本都会继续报这个错，然后重新把所有代码按sequelize的api文档的安装方法重新写了一个小demo，后面发现成功了。 然后我又在项目上重新写了一遍发现还是继续报这个错，然后我重新检查了下代码，发现报错是发生再db.js（间接定义model那个js）上，没把sequelize给exports出去， 导致如果直接调用sequelize.query()的时候会报错，所以我把db.js的sequelize放入导出对象中， 再在index.js中引入db，再使用sequelize.query()就不会报错了。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}]},{"title":"nodejs-跨域请求问题","slug":"前端/2018/101701","date":"2018-10-16T16:00:00.000Z","updated":"2020-09-25T03:04:27.392Z","comments":true,"path":"2018/10/17/前端/2018/101701/","link":"","permalink":"http://yoursite.com/2018/10/17/%E5%89%8D%E7%AB%AF/2018/101701/","excerpt":"","text":"概述在用nodejs做我的个人博客的时候，使用ajax请求数据的时候报了一个错，因为我用的数据库在服务器，项目放在我电脑本地，所以存在跨域请求的错: Failed to load http://192.168.1.7:3000/articleList?page=1&amp;&amp;limit=1: No “Access-Control-Allow-Origin” header is present on the requested resource. Origin “null” is therefore not allowed access. 正文原因 W3C标准里是这么实现HTTP跨域请求的， Cross-Origin Resource Sharing 简单的来说，就是跨域的目标服务器要返回一系列的Headers，通过这些Headers来控制是否同意跨域。 Access-Control-Allow-Origin HTTP Response Header Access-Control-Max-Age HTTP Response Header Access-Control-Allow-Credentials HTTP Response Header Access-Control-Allow-Methods HTTP Response Header Access-Control-Allow-Headers HTTP Response Header Origin HTTP Request Header Access-Control-Request-Method HTTP Request Header Access-Control-Request-Headers HTTP Request Header在 Request 包和 Response 包中都有一些。 其中最敏感的就是 Access-Control-Allow-Origin 这个 Header, 他是W3C标准里用来检查该跨域请求是否可以被通过。 (Access Control Check)。 解决方案在nodejs中使用koa时，有个cors模块是用来解决ajax跨域问题的，具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const Koa = require(&quot;koa&quot;);const bodyParser = require(&quot;koa-bodyparser&quot;);const controller = require(&quot;./controller&quot;);const templating = require(&quot;./templating&quot;);const cors = require(&quot;koa-cors&quot;);const app = new Koa();const isProduction = process.env.NODE_ENV === &quot;production&quot;;// 解决跨域问题app.use(cors());//记录URL以及页面执行时间app.use(async (ctx, next) =&gt; &#123; console.log(`Process $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;...`); var start = new Date().getTime(), execTime; await next(); execTime = new Date().getTime() - start; ctx.response.set(&quot;X-Response-Time&quot;, `$&#123;execTime&#125;ms`);&#125;);app.use(bodyParser()); //解析POST请求//负责给ctx加上render()来使用Nunjucksapp.use( templating(&quot;views&quot;, &#123; noCache: !isProduction, watch: !isProduction &#125;));app.use(controller()); //处理URL路由app.listen(3000);console.log(&quot;app started at port 3000...&quot;); 参考链接：https://www.jianshu.com/p/d7fcd17d79a9","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}]},{"title":"nodejs-请求体过大报413错误解决方法","slug":"前端/2018/101101","date":"2018-10-10T16:00:00.000Z","updated":"2020-09-25T03:04:27.391Z","comments":true,"path":"2018/10/11/前端/2018/101101/","link":"","permalink":"http://yoursite.com/2018/10/11/%E5%89%8D%E7%AB%AF/2018/101101/","excerpt":"","text":"概述nodeJs使用Koa框架。koa-bodyparser 接收数据。请求参数过大时会报错误代码413： 正文原因 使用koa-bodyparser会限制接收数据大小： formLimit: 表格限制默认 56kb jsonLimit：json传输默认限制 1M textLimit：文本传输默认限制 1M 解决方法在使用 bodyParser 的时候传一个对象进去，将 formLimit、jsonLimit、textLimit 的限制改为 2M 或根据需求确定数值。 12345app.use(bodyParser(&#123; &quot;formLimit&quot;:&quot;2mb&quot;, &quot;jsonLimit&quot;:&quot;2mb&quot;, &quot;textLimit&quot;:&quot;2mb&quot;&#125;))","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}]},{"title":"服务器-搭建服务器","slug":"后端/2018/101001","date":"2018-10-09T16:00:00.000Z","updated":"2020-09-25T03:04:27.407Z","comments":true,"path":"2018/10/10/后端/2018/101001/","link":"","permalink":"http://yoursite.com/2018/10/10/%E5%90%8E%E7%AB%AF/2018/101001/","excerpt":"","text":"概述由于个人需求，需要建个个人博客，方便把遇到的问题和解决的过程，总结写成博客，所以买了个服务器和域名，开始搭建我的服务器； 正文一.安装nginx参考链接：https://www.linuxidc.com/Linux/2016-09/134907.htm； 1.安装gcc： yum install gcc-c++2.安装PCRE pcre-devel： yum install -y pcre pcre-devel3.安装zlib： yum install -y zlib zlib-devel4.安装openssl： yum install -y openssl openssl-devel5.官网下载nginx的.tar.gz安装包，地址：https://nginx.org/en/download.html 6.解压： tar -zxvf nginx-1.14.0.tar.gz7.进去解压目录： cd nginx-1.14.08.使用默认配置： ./configure --prefix=/usr/local/nginx 编译安装： make 10.需要安装 libpcre3-dev,命令为： sudo apt-get install libpcre3-dev 安装nginx： sudo make install 12.启动nginx： sudo /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf13.重启nginx： /usr/local/nginx/sbin/nginx -s reload14.关闭nginx： cd /usr/local/nginx/sbin/ ./nginx -s stop二.安装node参考链接：https://www.cnblogs.com/baby123/p/6955396.html （下载node：https://nodejs.org/zh-cn/download/到服务器到/home/tool文件夹中） 1.解压： tar -xvf node-v10.13.0.tar.gz2.进入解压目录，执行ls命令： cd node-v10.13.0 &amp;&amp; ls3.测试node是否安装成功： ./node -v4.配置node全局配置： ln -s /home/tool/node-v11.0.0-linux-x64/bin/node /usr/local/bin/node5.配置npm全局配置： ln -s /home/tool/node-v11.0.0-linux-x64/bin/npm /usr/local/bin/npm（可以在任何目录下执行node和npm命令） 6.查看环境变量： echo $PATH（/usr/local/bin是环境变量PATH的内容，所以建立软链接后可以直接使用node命令） 三.安装mysql参考链接：https://www.cnblogs.com/starof/p/4680083.html 1.官网下载安装mysql-server wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm rpm -ivh mysql-community-release-el7-5.noarch.rpm yum install mysql-community-server2.安装成功后重启mysql服务： service mysqld restart3.初次安装mysql，root账户没有密码： mysql -u root -p root4.设置密码： mysql&gt; set password for","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"web前端页面优化方法","slug":"前端/2018/100701","date":"2018-10-06T16:00:00.000Z","updated":"2020-09-25T03:04:27.391Z","comments":true,"path":"2018/10/07/前端/2018/100701/","link":"","permalink":"http://yoursite.com/2018/10/07/%E5%89%8D%E7%AB%AF/2018/100701/","excerpt":"","text":"概述 在用户使用我们的网站时，网站的加载速度对是否能留住用户有着致命的影响，因此本文主要介绍部分优化页面的方法 正文1. 尽量减少 HTTP 请求作为第一条，可能也是最重要的一条。根据数据分析表明，有很大一部分用户访问会因为这一条而获得更好的访问体验。常见的减少 HTTP 请求的方法： 1) 合并文件，比如把多个 CSS 文件合成一个；Gulp,Grunt 构建工具: 合并CSS, 合并JS, CSS&amp;JS压缩； 2) CSS Sprites 雪碧图。利用 CSS background 相关元素进行背景图绝对定位； 3) 图片用base64 与 延迟加载；2 减少 DNS 查找：1）. 使用本地资源 ； 2）.使用加速器CDN；3. 避免重定向；不是绝对的避免，尽量减少。另外，应该注意一些不必要的重定向。 4 .Ajax可缓存：尽量让Ajax可缓存，响应时间对 Ajax 来说至关重要，否则用户体验绝对好不到哪里去。 5. 延迟载入组件：lazyload.js； 6. 预载入组件：require.js； 7. 减少 DOM 元素数量；8. 最小化iframe的数量：iframe 是 网站SEO 的大忌。所以针对前端优化来说 iframe 有其好处，也有其弊端，谨慎使用吧。 9. 杜绝 http 404 错误对页面链接的充分测试加上对 Web 服务器 error 日志的不断跟踪能有效减少 404 错误，也能提升用户体验： 1）. 杜绝所有网站现有的链接的404，死链接； 2）.自定义404页面，提醒用户，访问的页面不存在，并自动跳转至有效页面。 如： https://www.btluo.com/404.html；10.防止页面阻塞：css文件在头部引入，js在也页面尾部，防止页面阻塞；","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"服务器-1.配置https","slug":"后端/2018/100501","date":"2018-10-04T16:00:00.000Z","updated":"2020-09-25T03:04:27.406Z","comments":true,"path":"2018/10/05/后端/2018/100501/","link":"","permalink":"http://yoursite.com/2018/10/05/%E5%90%8E%E7%AB%AF/2018/100501/","excerpt":"","text":"概述 HTTPS，是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 http和https的区别就是，后者在网络传输过程中会很安全，原因就是给http安装了SSL证书。 正文一.开启nginx的ssl模块1.切换到nginx安装目录: cd /home/tool/nginx-1.14.02.查看nginx原有的模块: /usr/local/nginx/sbin/nginx -v3.重新配置: ./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module4.重新编译，不需要make install安装。否则会覆盖: make5.备份原有已装好的nginx: cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak6.将刚刚编译好的nginx覆盖掉原来的nginx(ngixn必须停止): 停止nginx： cd /usr/local/nginx/sbin/ ./nginx -s stop cp ./objs/nginx /usr/local/nginx/sbin/这时，会提示是否覆盖，请输入yes，直接回车默认不覆盖 7.启动nginx，查看nginx模块，发现已经添加: 启动nginx： sudo /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf查看nginx模块： /usr/local/nginx/sbin/nginx -V8.测试nginx是否正确: /usr/local/nginx/sbin/nginx -t（成功：nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful） 出错解决方案：https://blog.csdn.net/u014227715/article/details/77649156 二.配置https因为我使用的是阿里云的服务器，所以需要在阿里云上下载证书，来配置https，为了安全； （参考链接：https://www.cnblogs.com/tianhei/p/7726505.html） 购买证书链接：https://common-buy.aliyun.com/?spm=5176.2020520154.0.0.33e956a7ViBGU7&amp;commodityCode=cas#/buy ssl证书安装指南：https://help.aliyun.com/knowledge_detail/95505.html?spm=5176.2020520154.0.0.45d3y7Iiy7Iidz 1.选择证书: 2.申请证书: 3.下载证书上传到nginx文件夹中新建一个cert: 4.配置文件：打开nginx的nginx.conf文件，输入以下代码： 1234567891011121314151617server &#123; listen 443; server_name www.btluo.com;//绑定的域名 ssl on; root html; index index.html index.htm; ssl_certificate /home/tool/nginx-1.14.0/cert/a.pem; ssl_certificate_key /home/tool/nginx-1.14.0/cert/a.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / &#123; root html; index index.html index.htm; &#125;&#125; 5.查看nginx配置是否正确: /usr/local/nginx/sbin/nginx -t6.重启nginx： /usr/local/nginx/sbin/nginx -s reload7.通过netstat -tnlp指令来查看开启的端口是否成功。 8.访问页面： https://www.btluo.com 注：小程序使用https时需要先加入白名单，在小程序的“设置-开发设置”中把域名加入进去：","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"服务器-2.配置https遇到的问题","slug":"后端/2018/100502","date":"2018-10-04T16:00:00.000Z","updated":"2020-09-25T03:04:27.407Z","comments":true,"path":"2018/10/05/后端/2018/100502/","link":"","permalink":"http://yoursite.com/2018/10/05/%E5%90%8E%E7%AB%AF/2018/100502/","excerpt":"","text":"问题1： 因为小程序不支持http，所以我们需要通过服务器的nginx来实现网站https的配置； 配置链接：https://help.aliyun.com/knowledge_detail/95505.html?spm=5176.2020520154.0.0.45d3y7Iiy7Iidz 配置出错：但是在配置过程中，我按照步骤做，到最后输入/usr/local/nginx/sbin/nginx -t也成功了，但是再浏览器输入https://47.107.131.13的时候还是会报错404； 问题查询：通过netstat -tnlp指令来查看我开启的端口，后面发现我的443端口没有开启，然后我发现是我把443的端口文件写错位置了（通过linux输入ps -ef|grep nginx查看nginx开启位置）： 12345678910111213server &#123; listen 443 ssl; server_name www.btluo.com; ssl_certificate /home/tool/nginx-1.14.0/cert/cert-1541843453494_www.btluo.com.crt; ssl_certificate_key /home/tool/nginx-1.14.0/cert/cert-1541843453494_www.btluo.com.key; ssl_session_timeout 5m; location /api &#123; proxy_pass http://127.0.0.1:3000; &#125; location /img&#123; root /home; &#125;&#125; 解决方法重新找到/usr/local/nginx/sbin/nginx下面的nginx.conf文件把443服务开启之后就能正常输入https://47.107.131.13了。 问题2：在访问的时候，因为证书配置的是域名www.btluo.com，所以输入https://47.***.***.13的时候会出该网站的连接不是私密连接，可能存在风险； 解决方法：不使用ip做小程序的接口地址，改为域名； 其他：在小程序访问时，需要在小程序中的“设置-开发设置”中把域名加入进去： 然后就可以通过https://www.btluo.com/来写接口了。","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]}],"categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"IT","slug":"IT","permalink":"http://yoursite.com/categories/IT/"},{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"其他","slug":"其他","permalink":"http://yoursite.com/tags/%E5%85%B6%E4%BB%96/"},{"name":"HEXO","slug":"HEXO","permalink":"http://yoursite.com/tags/HEXO/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]}